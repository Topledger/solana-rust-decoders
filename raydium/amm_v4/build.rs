// build.rs - Simple instruction decoder for raydium AMM v4 (non-Anchor, single-byte tags)

use anyhow::Result;
use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::{format_ident, quote};
use serde_json::{from_str, Value};
use std::{fs, process::Command};

fn main() -> Result<()> {
    let path = "idls/raydium_amm_v4.json";
    let idl_json = fs::read_to_string(path)?;
    let idl: Value = from_str(&idl_json)?;

    let instructions = idl["instructions"].as_array()
        .ok_or_else(|| anyhow::anyhow!("No instructions array found"))?;

    println!("cargo:warning=Building raydium AMM v4 instruction decoder with {} instructions (non-Anchor, single-byte tags)", 
        instructions.len());

    // Generate simple instruction structs and decoders
    let (args_structs, accounts_structs, instruction_variants, decode_arms) = generate_instructions(&instructions)?;

    // Build simple output - instructions only
    let out = quote! {
        extern crate serde;
        // @generated by build.rs â€” DO NOT EDIT
        #[allow(dead_code)]

        use ::borsh::BorshDeserialize;

        pub use ix_data::*;
        pub use accounts_data::*;

        pub mod accounts_data {
            use serde::Serialize;
            #(#accounts_structs)*
        }

        pub mod ix_data {
            use serde::Serialize;
            #(#args_structs)*
        }

        #[derive(Debug, serde::Serialize)]
        #[serde(tag = "instruction_type")]
        pub enum Instruction {
            #(#instruction_variants)*
        }

        impl Instruction {
            pub fn decode(
                account_keys: &[String],
                data: &[u8],
            ) -> anyhow::Result<Self> {
                if data.is_empty() {
                    anyhow::bail!("Data is empty");
                }
                let (tag_byte, rest) = data.split_at(1);
                let tag = tag_byte[0];
                match tag {
                    #(#decode_arms)*
                    _ => anyhow::bail!("Unknown instruction tag: {}", tag),
                }
            }
        }

        pub mod events {
            use serde::Serialize;

            #[derive(Debug, serde::Serialize)]
            #[serde(tag = "event_type")]
            pub enum Event {
                // No events for AMM v4
            }

            pub const EVENT_LOG_DISCRIMINATOR: [u8; 8] = [0; 8]; // unused

            impl Event {
                pub fn decode(_data: &[u8]) -> anyhow::Result<Self> {
                    anyhow::bail!("Event decoding not implemented for AMM v4")
                }
            }
        }
    };

    fs::write("src/idl.rs", out.to_string())?;
    Command::new("rustfmt").arg("src/idl.rs").status()?;
    println!("cargo:warning=Generated AMM v4 instruction decoder for {} instructions!", instructions.len());
    Ok(())
}

fn generate_instructions(instructions: &[Value]) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let mut args_structs = Vec::new();
    let mut accounts_structs = Vec::new();
    let mut instruction_variants = Vec::new();
    let mut decode_arms = Vec::new();

    for (index, ix) in instructions.iter().enumerate() {
        let name = ix["name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing instruction name"))?;
        
        let pascal = name.to_upper_camel_case();
        let args_ty = format_ident!("{}Arguments", pascal);
        let accounts_ty = format_ident!("{}Accounts", pascal);
        let variant = format_ident!("{}", pascal);

        // AMM v4 uses single-byte instruction tags (0, 1, 2, ...)
        let tag = index as u8;

        // Generate simple args struct - skip complex types for now
        let empty_args = vec![];
        let args = ix["args"].as_array().unwrap_or(&empty_args);
        let args_fields: Vec<_> = args.iter().map(|arg| {
            let field_name = arg["name"].as_str().unwrap();
            let field_ident = format_ident!("{}", field_name.to_snake_case());
            let ty = map_simple_type(&arg["type"]);
            
            // Add serialize_with annotation for large numbers
            match arg["type"].as_str() {
                Some("u64") | Some("u128") | Some("i64") | Some("i128") => {
                    quote! {
                        #[serde(serialize_with = "crate::serialize_to_string")]
                        pub #field_ident: #ty,
                    }
                }
                _ => {
                    quote! { pub #field_ident: #ty, }
                }
            }
        }).collect();

        args_structs.push(quote! {
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub struct #args_ty {
                #(#args_fields)*
            }
        });

        // Generate accounts struct
        let empty_accounts = vec![];
        let accounts = ix["accounts"].as_array().unwrap_or(&empty_accounts);
        let acc_fields = accounts.iter().map(|acc| {
            let acc_name = acc["name"].as_str().unwrap();
            let f = format_ident!("{}", acc_name.to_snake_case());
            quote! { pub #f: String, }
        });
        accounts_structs.push(quote! {
            #[derive(Debug, serde::Serialize)]
            pub struct #accounts_ty {
                #(#acc_fields)*
                pub remaining: Vec<String>,
            }
        });

        // Generate instruction variant
        instruction_variants.push(quote! {
            #variant { accounts: #accounts_ty, args: #args_ty },
        });

        // Generate decode arm
        let idents: Vec<_> = accounts
            .iter()
            .map(|acc| format_ident!("{}", acc["name"].as_str().unwrap().to_snake_case()))
            .collect();
        let extract = idents.iter().map(|ident| {
            quote! {
                let #ident = keys.next().unwrap_or(&"".to_string()).clone();
            }
        });

        // Always use resilient handling for all instructions to handle insufficient data
        let always_handle_partial_data = true;

        if always_handle_partial_data {
            // Generate field assignments for partial deserialization
            let partial_field_assignments: Vec<_> = args.iter().enumerate().map(|(field_idx, arg)| {
                let field_name = arg["name"].as_str().unwrap();
                let field_ident = format_ident!("{}", field_name.to_snake_case());
                
                // Check if this field is optional
                let is_optional = if let Some(obj) = arg["type"].as_object() {
                    obj.contains_key("option")
                } else {
                    false
                };
                
                if is_optional {
                    quote! { #field_ident: None, }
                } else {
                    // For non-optional fields, try to read from available data
                    // Calculate byte offset for this field
                    let mut byte_offset = 0usize;
                    for (prev_idx, prev_arg) in args.iter().enumerate() {
                        if prev_idx >= field_idx { break; }
                        match prev_arg["type"].as_str() {
                            Some("u8") => byte_offset += 1,
                            Some("u16") => byte_offset += 2,
                            Some("u32") => byte_offset += 4,
                            Some("u64") => byte_offset += 8,
                            Some("publicKey") => byte_offset += 32,
                            _ => byte_offset += 4, // Default assumption
                        }
                    }
                    
                    match arg["type"].as_str() {
                        Some("u8") => {
                            quote! { #field_ident: if rest.len() > #byte_offset { rest[#byte_offset] } else { 0 }, }
                        }
                        Some("u16") => {
                            quote! { #field_ident: if rest.len() >= #byte_offset + 2 { 
                                u16::from_le_bytes([rest[#byte_offset], rest[#byte_offset + 1]]) 
                            } else { 0 }, }
                        }
                        Some("u32") => {
                            quote! { #field_ident: if rest.len() >= #byte_offset + 4 { 
                                u32::from_le_bytes([
                                    rest[#byte_offset], rest[#byte_offset + 1], 
                                    rest[#byte_offset + 2], rest[#byte_offset + 3]
                                ]) 
                            } else { 0 }, }
                        }
                        Some("u64") => {
                            quote! { #field_ident: if rest.len() >= #byte_offset + 8 { 
                                u64::from_le_bytes([
                                    rest[#byte_offset], rest[#byte_offset + 1], rest[#byte_offset + 2], rest[#byte_offset + 3],
                                    rest[#byte_offset + 4], rest[#byte_offset + 5], rest[#byte_offset + 6], rest[#byte_offset + 7]
                                ]) 
                            } else { 0 }, }
                        }
                        Some("publicKey") => {
                            quote! { #field_ident: if rest.len() >= #byte_offset + 32 { 
                                [
                                    rest[#byte_offset + 0], rest[#byte_offset + 1], rest[#byte_offset + 2], rest[#byte_offset + 3],
                                    rest[#byte_offset + 4], rest[#byte_offset + 5], rest[#byte_offset + 6], rest[#byte_offset + 7],
                                    rest[#byte_offset + 8], rest[#byte_offset + 9], rest[#byte_offset + 10], rest[#byte_offset + 11],
                                    rest[#byte_offset + 12], rest[#byte_offset + 13], rest[#byte_offset + 14], rest[#byte_offset + 15],
                                    rest[#byte_offset + 16], rest[#byte_offset + 17], rest[#byte_offset + 18], rest[#byte_offset + 19],
                                    rest[#byte_offset + 20], rest[#byte_offset + 21], rest[#byte_offset + 22], rest[#byte_offset + 23],
                                    rest[#byte_offset + 24], rest[#byte_offset + 25], rest[#byte_offset + 26], rest[#byte_offset + 27],
                                    rest[#byte_offset + 28], rest[#byte_offset + 29], rest[#byte_offset + 30], rest[#byte_offset + 31]
                                ]
                            } else { [0u8; 32] }, }
                        }
                        _ => {
                            // For complex types, use empty Vec<u8> as default
                            quote! { #field_ident: Vec::new(), }
                        }
                    }
                }
            }).collect();
            
            // Special handling for instructions with optional fields
            decode_arms.push(quote! {
                #tag => {
                    let mut rdr: &[u8] = rest;
                    let args = match #args_ty::deserialize(&mut rdr) {
                        Ok(args) => args,
                        Err(_) => {
                            // If normal deserialization fails, create args with available data
                            #args_ty {
                                #(#partial_field_assignments)*
                            }
                        }
                    };
                    let mut keys = account_keys.iter();
                    #(#extract)*
                    let remaining = keys.cloned().collect();
                    let accounts = #accounts_ty { #(#idents),*, remaining };
                    return Ok(Instruction::#variant { accounts, args });
                }
            });
        } else {
            // Normal handling for instructions without optional fields
            decode_arms.push(quote! {
                #tag => {
                    let mut rdr: &[u8] = rest;
                    let args = #args_ty::deserialize(&mut rdr)
                        .map_err(|e| anyhow::anyhow!("Failed to deserialize args for {}: {} (data length: {})", stringify!(#variant), e, rest.len()))?;
                    let mut keys = account_keys.iter();
                    #(#extract)*
                    let remaining = keys.cloned().collect();
                    let accounts = #accounts_ty { #(#idents),*, remaining };
                    return Ok(Instruction::#variant { accounts, args });
                }
            });
        }
    }

    Ok((args_structs, accounts_structs, instruction_variants, decode_arms))
}

// Simplified type mapping - only handle basic types, treat complex ones as Vec<u8>
fn map_simple_type(ty: &Value) -> proc_macro2::TokenStream {
    if let Some(s) = ty.as_str() {
        match s {
            "bool" => quote! { bool },
            "u8" => quote! { u8 },
            "i8" => quote! { i8 },
            "u16" => quote! { u16 },
            "i16" => quote! { i16 },
            "u32" => quote! { u32 },
            "i32" => quote! { i32 },
            "u64" => quote! { u64 },
            "i64" => quote! { i64 },
            "u128" => quote! { u128 },
            "i128" => quote! { i128 },
            "publicKey" => quote! { [u8; 32] },
            _ => {
                // For any unknown string type, use Vec<u8> as fallback
                quote! { Vec<u8> }
            }
        }
    } else if let Some(obj) = ty.as_object() {
        if let Some(_vec) = obj.get("vec") {
            quote! { Vec<u8> }  // Simplified - all vecs become Vec<u8>
        } else if let Some(_option_inner) = obj.get("option") {
            // Handle Option types - for simplicity, make them all Option<Vec<u8>>
            // but with proper Borsh deserialization that can handle missing data
            quote! { Option<Vec<u8>> }
        } else if let Some(_array) = obj.get("array") {
            quote! { Vec<u8> }  // Simplified - all arrays become Vec<u8>
        } else if let Some(_defined) = obj.get("defined") {
            quote! { Vec<u8> }  // Simplified - all custom types become Vec<u8>
        } else {
            quote! { Vec<u8> }
        }
    } else {
        quote! { Vec<u8> }
    }
} 