// build.rs - Comprehensive IDL parser for raydium Launchlab (instructions + events)

use anchor_idl::{GeneratorOptions, Idl, IdlInstructionAccountItem, IdlType};
use anyhow::Result;
use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::{format_ident, quote};
use serde_json::from_str;
use std::{fs, process::Command};

fn main() -> Result<()> {
    let path = "idls/raydium_launchlab.json";
    let idl_json = fs::read_to_string(path)?;
    let idl: Idl = from_str(&idl_json)?;

    println!("cargo:warning=Building raydium Launchlab parser with {} instructions, {} events, {} types", 
        idl.instructions.len(), idl.events.len(), idl.types.len());

    // Generate typedefs using built-in anchor-idl generator
    let mut opts = GeneratorOptions::default();
    opts.idl_path = path.into();
    let gen = opts.to_generator();
    let typedefs_tokens = anchor_idl::generate_typedefs(&gen.idl.types, &gen.struct_opts);

    // Use typedefs as-is without adding custom derives (like CLMM)
    let typedefs_with_serde = typedefs_tokens;

    // Generate all instruction structs and decoders
    let (args_structs, accounts_structs, instruction_variants, decode_arms) = generate_all_instructions(&idl)?;

    // Generate event structs and decoders
    let (_event_structs, event_variants, event_decode_arms) = generate_all_events(&idl)?;

    // Build the comprehensive output
    let out = quote! {
        extern crate serde;
        // @generated by build.rs â€” DO NOT EDIT
        #[allow(dead_code)]

        use ::borsh::BorshDeserialize;
        use anchor_lang::prelude::*;
        use serde::Serialize;

        pub use ix_data::*;
        pub use typedefs::*;
        pub use accounts_data::*;

        pub mod typedefs {
            use anchor_lang::prelude::*;
            
            #typedefs_with_serde
            
            // Manually provide a Default implementation for CurveParams so that
            // structs containing it (e.g. PoolCreateEvent) can derive Default.
            impl Default for CurveParams {
                fn default() -> Self {
                    Self::Constant { data: ConstantCurve::default() }
                }
            }
        }

        pub mod accounts_data {
            use serde::Serialize;
            #(#accounts_structs)*
        }

        pub mod ix_data {
            use serde::Serialize;
            use super::*;
            #(#args_structs)*
        }

        #[derive(Debug)]
        pub enum Instruction {
            #(#instruction_variants)*
        }

        impl Instruction {
            pub fn decode(
                account_keys: &[String],
                data: &[u8],
            ) -> anyhow::Result<Self> {
                if data.len() < 8 {
                    anyhow::bail!("Data too short: {}", data.len());
                }
                let (disc_slice, rest) = data.split_at(8);
                let disc: [u8; 8] = disc_slice.try_into().unwrap();
                match disc {
                    #(#decode_arms)*
                    _ => anyhow::bail!("Unknown discriminator: {:?}", disc),
                }
            }
        }

        pub mod events {
            use super::*;

            #[derive(Debug)]
            pub enum Event {
                #(#event_variants)*
            }

            // Anchor's fixed "log prefix" for events
            pub const EVENT_LOG_DISCRIMINATOR: [u8; 8] = [228, 69, 165, 46, 81, 203, 154, 29];

            impl Event {
                pub fn decode(data: &[u8]) -> anyhow::Result<Self> {
                    if data.len() < 16 {
                        anyhow::bail!("Event log too short: {}", data.len());
                    }
                    let wrapper: [u8; 8] = data[0..8].try_into().unwrap();
                    if wrapper != EVENT_LOG_DISCRIMINATOR {
                        anyhow::bail!("Invalid event wrapper: {:?}", wrapper);
                    }
                    let disc: [u8; 8] = data[8..16].try_into().unwrap();
                    match disc {
                        #(#event_decode_arms)*
                        _ => anyhow::bail!("Unknown event discriminator: {:?}", disc),
                    }
                }
            }
        }
    };

    fs::write("src/idl.rs", out.to_string())?;
    Command::new("rustfmt").arg("src/idl.rs").status()?;
    println!("cargo:warning=Generated Launchlab parser for {} instructions and {} events!", 
        idl.instructions.len(), idl.events.len());
    Ok(())
}

fn generate_all_instructions(idl: &Idl) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let mut args_structs = Vec::new();
    let mut accounts_structs = Vec::new();
    let mut instruction_variants = Vec::new();
    let mut decode_arms = Vec::new();

    for ix in &idl.instructions {
        let pascal = ix.name.to_upper_camel_case();
        let args_ty = format_ident!("{}Arguments", pascal);
        let accounts_ty = format_ident!("{}Accounts", pascal);
        let variant = format_ident!("{}", pascal);

        // Get discriminator from IDL
        let disc_bytes: [u8; 8] = ix.discriminator.clone().try_into()
            .map_err(|_| anyhow::anyhow!("Invalid discriminator length for instruction {}", ix.name))?;
        let disc_tokens = disc_bytes.iter().map(|b| quote! { #b }).collect::<Vec<_>>();

        // Generate args struct
        let args_fields: Vec<_> = ix.args.iter().map(|arg| {
            let field_ident = format_ident!("{}", arg.name.to_snake_case());
            let ty = map_idl_type(&arg.ty);
            quote! { pub #field_ident: #ty, }
        }).collect();

        args_structs.push(quote! {
            #[derive(::borsh::BorshDeserialize, Debug)]
            pub struct #args_ty {
                #(#args_fields)*
            }
        });

        // Generate accounts struct using flatten pattern
        let flat = flatten_accounts(&ix.accounts);
        let acc_fields = flat.iter().map(|acc| {
            let f = format_ident!("{}", acc.name.as_str());
            quote! { pub #f: String, }
        });
        accounts_structs.push(quote! {
            #[derive(Debug, Serialize)]
            pub struct #accounts_ty {
                #(#acc_fields)*
                pub remaining: Vec<String>,
            }
        });

        // Generate instruction variant
        instruction_variants.push(quote! {
            #variant { accounts: #accounts_ty, args: #args_ty },
        });

        // Generate decode arm
        let idents: Vec<_> = flat
            .iter()
            .map(|acc| format_ident!("{}", acc.name.as_str()))
            .collect();
        let extract = idents.iter().map(|ident| {
            quote! {
                let #ident = keys.next().unwrap_or(&"".to_string()).clone();
            }
        });

        decode_arms.push(quote! {
            [#(#disc_tokens),*] => {
                let mut rdr: &[u8] = rest;
                let args = #args_ty::deserialize(&mut rdr)?;
                let mut keys = account_keys.iter();
                #(#extract)*
                let remaining = keys.cloned().collect();
                let accounts = #accounts_ty { #(#idents),*, remaining };
                return Ok(Instruction::#variant { accounts, args });
            }
        });
    }

    Ok((args_structs, accounts_structs, instruction_variants, decode_arms))
}

fn generate_all_events(idl: &Idl) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let event_structs = Vec::new(); // Events are defined in typedefs
    let mut event_variants = Vec::new();
    let mut event_decode_arms = Vec::new();

    for event in &idl.events {
        let pascal = event.name.to_upper_camel_case();
        let event_ty = format_ident!("{}", pascal);
        let variant = format_ident!("{}", pascal);

        // Get discriminator from IDL
        let disc_bytes: [u8; 8] = event.discriminator.clone().try_into()
            .map_err(|_| anyhow::anyhow!("Invalid discriminator length for event {}", event.name))?;
        let disc_tokens = disc_bytes.iter().map(|b| quote! { #b }).collect::<Vec<_>>();

        // Generate event variant
        event_variants.push(quote! {
            #variant { args: #event_ty },
        });

        // Generate event decode arm
        event_decode_arms.push(quote! {
            [#(#disc_tokens),*] => {
                let mut rdr = &data[16..];
                let args = #event_ty::deserialize(&mut rdr)?;
                return Ok(Event::#variant { args });
            }
        });
    }

    Ok((event_structs, event_variants, event_decode_arms))
}

fn map_idl_type(ty: &IdlType) -> proc_macro2::TokenStream {
    match ty {
        IdlType::Bool => quote! { bool },
        IdlType::U8 => quote! { u8 },
        IdlType::I8 => quote! { i8 },
        IdlType::U16 => quote! { u16 },
        IdlType::I16 => quote! { i16 },
        IdlType::U32 => quote! { u32 },
        IdlType::I32 => quote! { i32 },
        IdlType::U64 => quote! { u64 },
        IdlType::I64 => quote! { i64 },
        IdlType::U128 => quote! { u128 },
        IdlType::I128 => quote! { i128 },
        IdlType::Bytes => quote! { Vec<u8> },
        IdlType::String => quote! { String },
        IdlType::Pubkey => quote! { [u8; 32usize] },
        IdlType::Vec(inner) => {
            let i = map_idl_type(inner);
            quote! { Vec<#i> }
        }
        IdlType::Array(inner, len) => {
            let i = map_idl_type(inner);
            match len {
                anchor_idl::IdlArrayLen::Generic(_) => {
                    // For generic array length, fall back to Vec
                    quote! { Vec<#i> }
                }
                anchor_idl::IdlArrayLen::Value(size) => {
                    let l = *size;
                    quote! { [#i; #l] }
                }
            }
        }
        IdlType::Defined { name, .. } => {
            let id = format_ident!("{}", name.to_upper_camel_case());
            quote! { #id }
        }
        IdlType::Option(inner) => {
            let i = map_idl_type(inner);
            quote! { Option<#i> }
        }
        _ => {
            // For any unsupported types, fall back to Vec<u8>
            quote! { Vec<u8> }
        }
    }
}

fn flatten_accounts<'a>(
    items: &'a [IdlInstructionAccountItem],
) -> Vec<&'a anchor_idl::IdlInstructionAccount> {
    let mut out = Vec::new();
    for item in items {
        match item {
            IdlInstructionAccountItem::Single(acc) => out.push(acc),
            IdlInstructionAccountItem::Composite(group) => {
                out.extend(flatten_accounts(&group.accounts));
            }
        }
    }
    out
} 