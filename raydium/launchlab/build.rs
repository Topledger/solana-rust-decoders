// build.rs - Comprehensive IDL parser for raydium Launchlab (instructions + events)

use anchor_idl::{GeneratorOptions, Idl, IdlInstructionAccountItem, IdlType};
use anyhow::Result;
use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::{format_ident, quote};
use serde_json::from_str;
use std::{fs, process::Command};

use syn;

fn main() -> Result<()> {
    let path = "idls/raydium_launchlab.json";
    let idl_json = fs::read_to_string(path)?;
    let idl: Idl = from_str(&idl_json)?;

    println!("cargo:warning=Building raydium Launchlab parser with {} instructions, {} events, {} types", 
        idl.instructions.len(), idl.events.len(), idl.types.len());

    // Generate typedefs using built-in anchor-idl generator
    let mut opts = GeneratorOptions::default();
    opts.idl_path = path.into();
    let gen = opts.to_generator();
    let typedefs_tokens = anchor_idl::generate_typedefs(&gen.idl.types, &gen.struct_opts);

    // Generate typedefs with Serialize support for JSON output
    println!("cargo:warning=About to process typedefs for serialization");
    let mut file = syn::parse2::<syn::File>(typedefs_tokens)?;
    for item in &mut file.items {
        if let syn::Item::Struct(s) = item {
            // ensure Serialize derive
            let derive_attr: syn::Attribute = syn::parse_quote!(#[derive(serde::Serialize)]);
            s.attrs.insert(0, derive_attr);
            // annotate Pubkey and Option<Pubkey> fields
            for field in &mut s.fields {
                match &field.ty {
                    // plain Pubkey
                    syn::Type::Path(path) if path.path.segments.last().unwrap().ident == "Pubkey" => {
                        let attr: syn::Attribute = syn::parse_quote!(#[serde(with = "pubkey_serde")]);
                        field.attrs.insert(0, attr);
                    }
                    // Option<Pubkey>
                    syn::Type::Path(path) if path.path.segments.len() == 1 && path.path.segments[0].ident == "Option" => {
                        if let syn::PathArguments::AngleBracketed(ab) = &path.path.segments[0].arguments {
                            if let Some(syn::GenericArgument::Type(inner_ty)) = ab.args.first() {
                                if let syn::Type::Path(inner_path) = inner_ty {
                                    if inner_path.path.segments.last().unwrap().ident == "Pubkey" {
                                        let attr: syn::Attribute = syn::parse_quote!(#[serde(with = "pubkey_serde_option")]);
                                        field.attrs.insert(0, attr);
                                    }
                                }
                            }
                        }
                    }
                    syn::Type::Array(arr) => {
                        // skip serializing very large fixed arrays (len > 32) to avoid serde limitations
                        if let syn::Expr::Lit(expr_lit) = &arr.len {
                            if let syn::Lit::Int(lit_int) = &expr_lit.lit {
                                if let Ok(len_val) = lit_int.base10_parse::<usize>() {
                                    if len_val > 32 {
                                        let attr: syn::Attribute = syn::parse_quote!(#[serde(skip_serializing)]);
                                        field.attrs.insert(0, attr);
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                    syn::Type::Path(path) if {
                        let id = &path.path.segments.last().unwrap().ident;
                        id == "u64" || id == "u128"
                    } => {
                        let attr: syn::Attribute = syn::parse_quote!(#[serde(serialize_with = "crate::serialize_to_string")]);
                        field.attrs.insert(0, attr);
                    }
                    _ => {}
                }
            }
        }
        if let syn::Item::Enum(e) = item {
            // ensure Serialize derive on enums too
            let derive_attr: syn::Attribute = syn::parse_quote!(#[derive(serde::Serialize)]);
            e.attrs.insert(0, derive_attr);
        }
    }
    let typedefs_with_serde = quote! { #file };
    println!("cargo:warning=Finished processing typedefs");

    // Generate all instruction structs and decoders
    let (args_structs, accounts_structs, instruction_variants, decode_arms) = generate_all_instructions(&idl)?;

    // Generate event structs and decoders
    let (_event_structs, event_variants, event_decode_arms) = generate_all_events(&idl)?;

    // Build the comprehensive output
    let out = quote! {
        extern crate serde;
        // @generated by build.rs â€” DO NOT EDIT
        #[allow(dead_code)]

        use ::borsh::BorshDeserialize;
        use anchor_lang::prelude::*;

        pub use ix_data::*;
        pub use typedefs::*;
        pub use accounts_data::*;

        pub mod typedefs {
            use anchor_lang::prelude::*;
            use serde::Serialize;
            use crate::pubkey_serializer::pubkey_serde;
            use crate::pubkey_serializer::pubkey_serde_option;
            
            #typedefs_with_serde
            
            // Manually provide a Default implementation for CurveParams so that
            // structs containing it (e.g. PoolCreateEvent) can derive Default.
            impl Default for CurveParams {
                fn default() -> Self {
                    Self::Constant { data: ConstantCurve::default() }
                }
            }
        }

        pub mod accounts_data {
            use serde::Serialize;
            #(#accounts_structs)*
        }

        pub mod ix_data {
            use serde::Serialize;
            use super::*;
            use crate::pubkey_serializer::pubkey_serde;
            use crate::pubkey_serializer::pubkey_serde_option;
            #(#args_structs)*
        }

        #[derive(Debug, serde::Serialize)]
        #[serde(tag = "instruction_type")]
        pub enum Instruction {
            #(#instruction_variants)*
        }

        impl Instruction {
            pub fn decode(
                account_keys: &[String],
                data: &[u8],
            ) -> anyhow::Result<Self> {
                if data.len() < 8 {
                    anyhow::bail!("Data too short: {}", data.len());
                }
                let (disc_slice, rest) = data.split_at(8);
                let disc: [u8; 8] = disc_slice.try_into().unwrap();
                match disc {
                    #(#decode_arms)*
                    _ => anyhow::bail!("Unknown discriminator: {:?}", disc),
                }
            }
        }

        pub mod events {
            use super::*;

            #[derive(Debug, serde::Serialize)]
            #[serde(tag = "event_type")]
            pub enum Event {
                #(#event_variants)*
            }

            // Anchor's fixed "log prefix" for events
            pub const EVENT_LOG_DISCRIMINATOR: [u8; 8] = [228, 69, 165, 46, 81, 203, 154, 29];

            impl Event {
                pub fn decode(data: &[u8]) -> anyhow::Result<Self> {
                    if data.len() < 16 {
                        anyhow::bail!("Event log too short: {}", data.len());
                    }
                    let wrapper: [u8; 8] = data[0..8].try_into().unwrap();
                    if wrapper != EVENT_LOG_DISCRIMINATOR {
                        anyhow::bail!("Invalid event wrapper: {:?}", wrapper);
                    }
                    let disc: [u8; 8] = data[8..16].try_into().unwrap();
                    match disc {
                        #(#event_decode_arms)*
                        _ => anyhow::bail!("Unknown event discriminator: {:?}", disc),
                    }
                }
            }
        }
    };

    let generated_code = out.to_string();
    fs::write("src/idl.rs", generated_code)?;
    
    Command::new("rustfmt").arg("src/idl.rs").status()?;
    println!("cargo:warning=Generated comprehensive parser for all {} raydium Launchlab instructions and {} events!", 
        idl.instructions.len(), idl.events.len());
    Ok(())
}

fn generate_all_instructions(idl: &Idl) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let mut args_structs = Vec::new();
    let mut accounts_structs = Vec::new();
    let mut instruction_variants = Vec::new();
    let mut decode_arms = Vec::new();

    for ix in &idl.instructions {
        let pascal = ix.name.to_upper_camel_case();
        let args_ty = format_ident!("{}Arguments", pascal);
        let accounts_ty = format_ident!("{}Accounts", pascal);
        let variant = format_ident!("{}", pascal);

        // Get discriminator from IDL
        let disc_bytes: [u8; 8] = ix.discriminator.clone().try_into()
            .map_err(|_| anyhow::anyhow!("Invalid discriminator length for instruction {}", ix.name))?;
        let disc_tokens = disc_bytes.iter().map(|b| quote! { #b }).collect::<Vec<_>>();

        // Generate args struct with serde annotations
        let args_fields: Vec<_> = ix.args.iter().map(|arg| {
            let field_ident = format_ident!("{}", arg.name.to_snake_case());
            let ty = map_idl_type(&arg.ty);

            match &arg.ty {
                anchor_idl::IdlType::U64 | anchor_idl::IdlType::U128 => {
                    quote! {
                        #[serde(serialize_with = "crate::serialize_to_string")]
                        pub #field_ident: #ty,
                    }
                }
                anchor_idl::IdlType::Pubkey => {
                    quote! {
                        #[serde(with = "pubkey_serde")]
                        pub #field_ident: #ty,
                    }
                }
                anchor_idl::IdlType::Option(inner) if matches!(**inner, anchor_idl::IdlType::Pubkey) => {
                    quote! {
                        #[serde(with = "pubkey_serde_option")]
                        pub #field_ident: #ty,
                    }
                }
                _ => {
                    quote! {
                        pub #field_ident: #ty,
                    }
                }
            }
        }).collect();

        args_structs.push(quote! {
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub struct #args_ty {
                #(#args_fields)*
            }
        });

        // Generate accounts struct using flatten pattern
        let flat = flatten_accounts(&ix.accounts);
        let acc_fields = flat.iter().map(|acc| {
            let f = format_ident!("{}", acc.name.as_str());
            quote! { pub #f: String, }
        });
        accounts_structs.push(quote! {
            #[derive(Debug, serde::Serialize)]
            pub struct #accounts_ty {
                #(#acc_fields)*
                pub remaining: Vec<String>,
            }
        });

        // Generate instruction variant
        instruction_variants.push(quote! {
            #variant { accounts: #accounts_ty, args: #args_ty },
        });

        // Generate decode arm
        let idents: Vec<_> = flat
            .iter()
            .map(|acc| format_ident!("{}", acc.name.as_str()))
            .collect();
        let extract = idents.iter().map(|ident| {
            quote! {
                let #ident = keys.next().unwrap_or(&"".to_string()).clone();
            }
        });

        // Special handling for UpdatePlatformConfig to catch unknown enum variants
        let args_deserialization = if ix.name == "update_platform_config" {
            quote! {
                let args = match #args_ty::deserialize(&mut rdr) {
                    Ok(args) => args,
                    Err(_) => {
                        // If deserialization fails, try to handle unknown enum variants
                        let mut rdr_fallback: &[u8] = rest;
                        let variant_index = u8::deserialize(&mut rdr_fallback)?;
                        
                        // If it's an unknown variant, consume the rest as raw bytes
                        let remaining_data = rdr_fallback.to_vec();
                        
                        #args_ty {
                            param: PlatformConfigParam::Unknown(remaining_data),
                        }
                    }
                };
            }
        } else {
            quote! {
                let args = #args_ty::deserialize(&mut rdr)?;
            }
        };

        decode_arms.push(quote! {
            [#(#disc_tokens),*] => {
                let mut rdr: &[u8] = rest;
                #args_deserialization
                let mut keys = account_keys.iter();
                #(#extract)*
                let remaining = keys.cloned().collect();
                let accounts = #accounts_ty { #(#idents),*, remaining };
                return Ok(Instruction::#variant { accounts, args });
            }
        });
    }

    Ok((args_structs, accounts_structs, instruction_variants, decode_arms))
}

fn generate_all_events(idl: &Idl) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let event_structs = Vec::new(); // Events are defined in typedefs
    let mut event_variants = Vec::new();
    let mut event_decode_arms = Vec::new();

    for event in &idl.events {
        let pascal = event.name.to_upper_camel_case();
        let event_ty = format_ident!("{}", pascal);
        let variant = format_ident!("{}", pascal);

        // Get discriminator from IDL
        let disc_bytes: [u8; 8] = event.discriminator.clone().try_into()
            .map_err(|_| anyhow::anyhow!("Invalid discriminator length for event {}", event.name))?;
        let disc_tokens = disc_bytes.iter().map(|b| quote! { #b }).collect::<Vec<_>>();

        // Generate event variant
        event_variants.push(quote! {
            #variant { args: #event_ty },
        });

        // Generate event decode arm
        event_decode_arms.push(quote! {
            [#(#disc_tokens),*] => {
                let mut rdr = &data[16..];
                let args = #event_ty::deserialize(&mut rdr)?;
                return Ok(Event::#variant { args });
            }
        });
    }

    Ok((event_structs, event_variants, event_decode_arms))
}

fn map_idl_type(ty: &IdlType) -> proc_macro2::TokenStream {
    match ty {
        IdlType::Bool => quote! { bool },
        IdlType::U8 => quote! { u8 },
        IdlType::I8 => quote! { i8 },
        IdlType::U16 => quote! { u16 },
        IdlType::I16 => quote! { i16 },
        IdlType::U32 => quote! { u32 },
        IdlType::I32 => quote! { i32 },
        IdlType::U64 => quote! { u64 },
        IdlType::I64 => quote! { i64 },
        IdlType::U128 => quote! { u128 },
        IdlType::I128 => quote! { i128 },
        IdlType::Bytes => quote! { Vec<u8> },
        IdlType::String => quote! { String },
        IdlType::Pubkey => quote! { Pubkey },  // Changed from [u8; 32usize] to Pubkey
        IdlType::Vec(inner) => {
            let i = map_idl_type(inner);
            quote! { Vec<#i> }
        }
        IdlType::Array(inner, len) => {
            let i = map_idl_type(inner);
            match len {
                anchor_idl::IdlArrayLen::Generic(_) => {
                    // For generic array length, fall back to Vec
                    quote! { Vec<#i> }
                }
                anchor_idl::IdlArrayLen::Value(size) => {
                    let l = *size;
                    quote! { [#i; #l] }
                }
            }
        }
        IdlType::Defined { name, .. } => {
            let id = format_ident!("{}", name.to_upper_camel_case());
            quote! { #id }
        }
        IdlType::Option(inner) => {
            match &**inner {
                IdlType::Bool => quote! { bool },
                _ => {
                    let i = map_idl_type(inner);
                    quote! { Option<#i> }
                }
            }
        }
        _ => {
            // For any unsupported types, fall back to Vec<u8>
            quote! { Vec<u8> }
        }
    }
}

fn flatten_accounts<'a>(
    items: &'a [IdlInstructionAccountItem],
) -> Vec<&'a anchor_idl::IdlInstructionAccount> {
    let mut out = Vec::new();
    for item in items {
        match item {
            IdlInstructionAccountItem::Single(acc) => out.push(acc),
            IdlInstructionAccountItem::Composite(group) => {
                out.extend(flatten_accounts(&group.accounts));
            }
        }
    }
    out
} 