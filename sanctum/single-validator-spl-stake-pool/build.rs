// build.rs - Simple instruction decoder for Sanctum Single Validator SPL Stake Pool (non-Anchor, single-byte tags)

use anyhow::Result;
use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::{format_ident, quote};
use serde_json::{from_str, Value};
use std::{fs, process::Command};

fn main() -> Result<()> {
    let path = "idls/single_validator.json";
    let idl_json = fs::read_to_string(path)?;
    let idl: Value = from_str(&idl_json)?;

    let instructions = idl["instructions"].as_array()
        .ok_or_else(|| anyhow::anyhow!("No instructions array found"))?;

    println!("cargo:warning=Building Sanctum Single Validator SPL Stake Pool instruction decoder with {} instructions (non-Anchor, single-byte tags)", 
        instructions.len());

    // Generate simple instruction structs and decoders
    let (args_structs, accounts_structs, instruction_variants, decode_arms) = generate_instructions(&instructions)?;

    // Build simple output - instructions only
    let out = quote! {
        extern crate serde;
        // @generated by build.rs â€” DO NOT EDIT
        #[allow(dead_code)]

        use ::borsh::BorshDeserialize;
        use serde::Serialize;

        pub use ix_data::*;
        pub use accounts_data::*;

        pub mod accounts_data {
            use serde::Serialize;
            #(#accounts_structs)*
        }

        pub mod ix_data {
            use serde::Serialize;
            #(#args_structs)*
        }

        #[derive(Debug, serde::Serialize)]
        #[serde(tag = "instruction_type")]
        pub enum Instruction {
            #(#instruction_variants)*
        }

        impl Instruction {
            pub fn decode(
                account_keys: &[String],
                data: &[u8],
            ) -> anyhow::Result<Self> {
                if data.is_empty() {
                    anyhow::bail!("Data is empty");
                }
                let (tag_byte, rest) = data.split_at(1);
                let tag = tag_byte[0];
                match tag {
                    #(#decode_arms)*
                    _ => anyhow::bail!("Unknown instruction tag: {}", tag),
                }
            }
        }

        pub mod events {
            use serde::Serialize;

            #[derive(Debug, Serialize)]
            #[serde(tag = "event_type")]
            pub enum Event {
                // No events for SPL Stake Pool
            }

            pub const EVENT_LOG_DISCRIMINATOR: [u8; 8] = [0; 8]; // unused

            impl Event {
                pub fn decode(_data: &[u8]) -> anyhow::Result<Self> {
                    anyhow::bail!("Event decoding not implemented for SPL Stake Pool")
                }
            }
        }
    };

    fs::write("src/idl.rs", out.to_string())?;
    Command::new("rustfmt").arg("src/idl.rs").status()?;
    println!("cargo:warning=Generated Sanctum Single Validator SPL Stake Pool instruction decoder for {} instructions!", instructions.len());
    Ok(())
}

fn generate_instructions(instructions: &[Value]) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let mut args_structs = Vec::new();
    let mut accounts_structs = Vec::new();
    let mut instruction_variants = Vec::new();
    let mut decode_arms = Vec::new();

    for (index, ix) in instructions.iter().enumerate() {
        let name = ix["name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing instruction name"))?;
        
        let pascal = name.to_upper_camel_case();
        let args_ty = format_ident!("{}Arguments", pascal);
        let accounts_ty = format_ident!("{}Accounts", pascal);
        let variant = format_ident!("{}", pascal);

        // Extract discriminant value from IDL, fallback to index for compatibility
        let tag = if let Some(discriminant) = ix.get("discriminant") {
            discriminant["value"].as_u64().unwrap_or(index as u64) as u8
        } else {
            index as u8
        };

        // Generate simple args struct - skip complex types for now
        let empty_args = vec![];
        let args = ix["args"].as_array().unwrap_or(&empty_args);
        let args_fields: Vec<_> = args.iter().map(|arg| {
            let field_name = arg["name"].as_str().unwrap();
            let field_ident = format_ident!("{}", field_name.to_snake_case());
            let ty_json = &arg["type"];
            let ty = map_simple_type(ty_json);
            // For large integers, serialize as string to avoid JS number limit
            if let Some(s) = ty_json.as_str() {
                match s {
                    "u64" | "u128" => {
                        quote! { #[serde(serialize_with = "crate::serialize_to_string")] pub #field_ident: #ty, }
                    }
                    _ => quote! { pub #field_ident: #ty, },
                }
            } else {
                quote! { pub #field_ident: #ty, }
            }
        }).collect();

        args_structs.push(quote! {
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub struct #args_ty {
                #(#args_fields)*
            }
        });

        // Generate accounts struct
        let empty_accounts = vec![];
        let accounts = ix["accounts"].as_array().unwrap_or(&empty_accounts);
        let acc_fields = accounts.iter().map(|acc| {
            let acc_name = acc["name"].as_str().unwrap();
            let f = format_ident!("{}", acc_name.to_snake_case());
            quote! { pub #f: String, }
        });
        accounts_structs.push(quote! {
            #[derive(Debug, serde::Serialize)]
            pub struct #accounts_ty {
                #(#acc_fields)*
                pub remaining: Vec<String>,
            }
        });

        // Generate instruction variant with flattened fields
        instruction_variants.push(quote! {
            #variant {
                accounts: #accounts_ty,
                args: #args_ty
            },
        });

        // Generate decode arm
        let idents: Vec<_> = accounts
            .iter()
            .map(|acc| format_ident!("{}", acc["name"].as_str().unwrap().to_snake_case()))
            .collect();
        let extract = idents.iter().map(|ident| {
            quote! {
                let #ident = keys.next().unwrap_or(&"".to_string()).clone();
            }
        });

        decode_arms.push(quote! {
            #tag => {
                let mut rdr: &[u8] = rest;
                let args = #args_ty::deserialize(&mut rdr)?;
                let mut keys = account_keys.iter();
                #(#extract)*
                let remaining = keys.cloned().collect();
                let accounts = #accounts_ty { #(#idents),*, remaining };
                return Ok(Instruction::#variant { accounts, args });
            }
        });
    }

    Ok((args_structs, accounts_structs, instruction_variants, decode_arms))
}

// Simplified type mapping - only handle basic types, treat complex ones as Vec<u8>
fn map_simple_type(ty: &Value) -> proc_macro2::TokenStream {
    if let Some(s) = ty.as_str() {
        match s {
            "bool" => quote! { bool },
            "u8" => quote! { u8 },
            "i8" => quote! { i8 },
            "u16" => quote! { u16 },
            "i16" => quote! { i16 },
            "u32" => quote! { u32 },
            "i32" => quote! { i32 },
            "u64" => quote! { u64 },
            "i64" => quote! { i64 },
            "u128" => quote! { u128 },
            "i128" => quote! { i128 },
            "publicKey" => quote! { [u8; 32] },
            _ => {
                // For any unknown string type, use Vec<u8> as fallback
                quote! { Vec<u8> }
            }
        }
    } else if let Some(obj) = ty.as_object() {
        if let Some(_vec) = obj.get("vec") {
            quote! { Vec<u8> }  // Simplified - all vecs become Vec<u8>
        } else if let Some(_option) = obj.get("option") {
            quote! { Option<Vec<u8>> }  // Simplified - all options become Option<Vec<u8>>
        } else if let Some(_array) = obj.get("array") {
            quote! { Vec<u8> }  // Simplified - all arrays become Vec<u8>
        } else if let Some(_defined) = obj.get("defined") {
            quote! { Vec<u8> }  // Simplified - all custom types become Vec<u8>
        } else {
            quote! { Vec<u8> }
        }
    } else {
        quote! { Vec<u8> }
    }
} 