// build.rs - Simple instruction decoder for Sanctum Single Validator SPL Stake Pool (non-Anchor, single-byte tags)

use anyhow::Result;
use heck::{ToSnakeCase, ToUpperCamelCase};
use quote::{format_ident, quote};
use serde_json::{from_str, Value};
use std::{fs, process::Command};

fn main() -> Result<()> {
    let path = "idls/single_validator.json";
    let idl_json = fs::read_to_string(path)?;
    let idl: Value = from_str(&idl_json)?;

    let instructions = idl["instructions"].as_array()
        .ok_or_else(|| anyhow::anyhow!("No instructions array found"))?;

    println!("cargo:warning=Building Sanctum Single Validator SPL Stake Pool instruction decoder with {} instructions (non-Anchor, single-byte tags)", 
        instructions.len());

    // Generate simple instruction structs and decoders
    let (args_structs, accounts_structs, instruction_variants, decode_arms) = generate_instructions(&instructions)?;

    // Build simple output - instructions only
    let out = quote! {
        extern crate serde;
        // @generated by build.rs â€” DO NOT EDIT
        #[allow(dead_code)]

        use ::borsh::BorshDeserialize;
        use serde::Serialize;

        pub use ix_data::*;
        pub use accounts_data::*;

        pub mod accounts_data {
            use serde::Serialize;
            #(#accounts_structs)*
        }

        pub mod ix_data {
            use serde::Serialize;
            
            // Define Fee struct for SPL Stake Pool
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub struct Fee {
                #[serde(serialize_with = "crate::serialize_to_string")]
                pub denominator: u64,
                #[serde(serialize_with = "crate::serialize_to_string")]
                pub numerator: u64,
            }
            
            // Define FeeType enum for SPL Stake Pool
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            #[serde(tag = "type", content = "value")]
            pub enum FeeType {
                SolReferral(u8),
                StakeReferral(u8),
                Epoch(Fee),
                StakeWithdrawal(Fee),
                SolDeposit(Fee),
                StakeDeposit(Fee),
                SolWithdrawal(Fee),
            }
            
            // Define FundingType enum for SPL Stake Pool
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub enum FundingType {
                StakeDeposit,
                SolDeposit,
                SolWithdraw,
            }
            
            // Define PreferredValidatorType enum for SPL Stake Pool
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub enum PreferredValidatorType {
                Deposit,
                Withdraw,
            }
            
            #(#args_structs)*
        }

        #[derive(Debug, serde::Serialize)]
        #[serde(tag = "instruction_type")]
        pub enum Instruction {
            #(#instruction_variants)*
        }

        impl Instruction {
            pub fn decode(
                account_keys: &[String],
                data: &[u8],
            ) -> anyhow::Result<Self> {
                if data.is_empty() {
                    anyhow::bail!("Data is empty");
                }
                let (tag_byte, rest) = data.split_at(1);
                let tag = tag_byte[0];
                match tag {
                    #(#decode_arms)*
                    _ => anyhow::bail!("Unknown instruction tag: {}", tag),
                }
            }
        }

        pub mod events {
            use serde::Serialize;

            #[derive(Debug, Serialize)]
            #[serde(tag = "event_type")]
            pub enum Event {
                // No events for SPL Stake Pool
            }

            pub const EVENT_LOG_DISCRIMINATOR: [u8; 8] = [0; 8]; // unused

            impl Event {
                pub fn decode(_data: &[u8]) -> anyhow::Result<Self> {
                    anyhow::bail!("Event decoding not implemented for SPL Stake Pool")
                }
            }
        }
    };

    fs::write("src/idl.rs", out.to_string())?;
    Command::new("rustfmt").arg("src/idl.rs").status()?;
    println!("cargo:warning=Generated Sanctum Single Validator SPL Stake Pool instruction decoder for {} instructions!", instructions.len());
    Ok(())
}

fn generate_instructions(instructions: &[Value]) -> Result<(Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>, Vec<proc_macro2::TokenStream>)> {
    let mut args_structs = Vec::new();
    let mut accounts_structs = Vec::new();
    let mut instruction_variants = Vec::new();
    let mut decode_arms = Vec::new();

    for (index, ix) in instructions.iter().enumerate() {
        let name = ix["name"].as_str()
            .ok_or_else(|| anyhow::anyhow!("Missing instruction name"))?;
        
        let pascal = name.to_upper_camel_case();
        let args_ty = format_ident!("{}Arguments", pascal);
        let accounts_ty = format_ident!("{}Accounts", pascal);
        let variant = format_ident!("{}", pascal);

        // Extract discriminant value from IDL, fallback to index for compatibility
        let tag = if let Some(discriminant) = ix.get("discriminant") {
            discriminant["value"].as_u64().unwrap_or(index as u64) as u8
        } else {
            index as u8
        };

            // Generate args struct with proper Fee type handling
    let empty_args = vec![];
    let args = ix["args"].as_array().unwrap_or(&empty_args);
    let args_fields: Vec<_> = args.iter().map(|arg| {
        let field_name = arg["name"].as_str().unwrap();
        let field_ident = format_ident!("{}", field_name.to_snake_case());
        let ty_json = &arg["type"];
        let ty = map_simple_type(ty_json);
        
        // Special handling for custom type arguments
        if let Some(obj) = ty_json.as_object() {
            if let Some(defined_name) = obj.get("defined").and_then(|v| v.as_str()) {
                match defined_name {
                    "Fee" => return quote! { pub #field_ident: Fee, },
                    "FeeType" => return quote! { pub #field_ident: FeeType, },
                    "FundingType" => return quote! { pub #field_ident: FundingType, },
                    "PreferredValidatorType" => return quote! { pub #field_ident: PreferredValidatorType, },
                    _ => {} // Fall through to default handling
                }
            }
        }
        
        // Handle special serialization cases
        if let Some(s) = ty_json.as_str() {
            match s {
                "u64" | "u128" => {
                    quote! { #[serde(serialize_with = "crate::serialize_to_string")] pub #field_ident: #ty, }
                }
                _ => quote! { pub #field_ident: #ty, },
            }
        } else if let Some(obj) = ty_json.as_object() {
            if let Some(option_inner) = obj.get("option") {
                if let Some(s) = option_inner.as_str() {
                    if s == "publicKey" {
                        return quote! { #[serde(with = "crate::pubkey_serializer::pubkey_serde_option")] pub #field_ident: #ty, };
                    }
                }
            }
            quote! { pub #field_ident: #ty, }
        } else {
            quote! { pub #field_ident: #ty, }
        }
    }).collect();

        args_structs.push(quote! {
            #[derive(::borsh::BorshDeserialize, Debug, serde::Serialize)]
            pub struct #args_ty {
                #(#args_fields)*
            }
        });

        // Generate accounts struct
        let empty_accounts = vec![];
        let accounts = ix["accounts"].as_array().unwrap_or(&empty_accounts);
        let acc_fields = accounts.iter().map(|acc| {
            let acc_name = acc["name"].as_str().unwrap();
            let f = format_ident!("{}", acc_name.to_snake_case());
            
            // Check if account is marked as optional in IDL
            let is_optional = acc.get("isOptional").and_then(|v| v.as_bool()).unwrap_or(false);
            
            if is_optional {
                quote! { pub #f: Option<String>, }
            } else {
                quote! { pub #f: String, }
            }
        });
        accounts_structs.push(quote! {
            #[derive(Debug, serde::Serialize)]
            pub struct #accounts_ty {
                #(#acc_fields)*
                pub remaining: Vec<String>,
            }
        });

        // Generate instruction variant with flattened fields
        instruction_variants.push(quote! {
            #variant {
                accounts: #accounts_ty,
                args: #args_ty
            },
        });

        // Generate decode arm with proper optional account handling
        let required_count = accounts.iter().filter(|acc| {
            !acc.get("isOptional").and_then(|v| v.as_bool()).unwrap_or(false)
        }).count();
        let optional_count = accounts.iter().filter(|acc| {
            acc.get("isOptional").and_then(|v| v.as_bool()).unwrap_or(false)
        }).count();
        
        let idents: Vec<_> = accounts
            .iter()
            .map(|acc| format_ident!("{}", acc["name"].as_str().unwrap().to_snake_case()))
            .collect();
        
        // Separate required and optional account extractions
        let required_extracts: Vec<_> = accounts.iter().zip(&idents).filter_map(|(acc, ident)| {
            let is_optional = acc.get("isOptional").and_then(|v| v.as_bool()).unwrap_or(false);
            if !is_optional {
                Some(quote! { let #ident = required_iter.next().unwrap().clone(); })
            } else {
                None
            }
        }).collect();
        
        let optional_extracts: Vec<_> = accounts.iter().zip(&idents).filter_map(|(acc, ident)| {
            let is_optional = acc.get("isOptional").and_then(|v| v.as_bool()).unwrap_or(false);
            if is_optional {
                Some(quote! { let #ident = optional_iter.next().map(|s| s.clone()); })
            } else {
                None
            }
        }).collect();

        decode_arms.push(quote! {
            #tag => {
                let mut rdr: &[u8] = rest;
                let args = #args_ty::deserialize(&mut rdr)?;
                
                // Check minimum required accounts
                if account_keys.len() < #required_count {
                    anyhow::bail!("Insufficient accounts: got {}, need at least {} for required accounts", 
                        account_keys.len(), #required_count);
                }
                
                // First pass: extract required accounts
                let mut required_iter = account_keys.iter().take(#required_count);
                #(#required_extracts)*
                
                // Second pass: extract optional accounts from remaining
                let mut optional_iter = account_keys.iter().skip(#required_count);
                #(#optional_extracts)*
                
                let remaining = if account_keys.len() > (#required_count + #optional_count) {
                    account_keys[(#required_count + #optional_count)..].to_vec()
                } else {
                    Vec::new()
                };
                let accounts = #accounts_ty { #(#idents),*, remaining };
                return Ok(Instruction::#variant { accounts, args });
            }
        });
    }

    Ok((args_structs, accounts_structs, instruction_variants, decode_arms))
}

// Simplified type mapping - only handle basic types, treat complex ones as Vec<u8>
fn map_simple_type(ty: &Value) -> proc_macro2::TokenStream {
    if let Some(s) = ty.as_str() {
        match s {
            "bool" => quote! { bool },
            "u8" => quote! { u8 },
            "i8" => quote! { i8 },
            "u16" => quote! { u16 },
            "i16" => quote! { i16 },
            "u32" => quote! { u32 },
            "i32" => quote! { i32 },
            "u64" => quote! { u64 },
            "i64" => quote! { i64 },
            "u128" => quote! { u128 },
            "i128" => quote! { i128 },
            "publicKey" => quote! { [u8; 32] },
            _ => {
                // For any unknown string type, use Vec<u8> as fallback
                quote! { Vec<u8> }
            }
        }
    } else if let Some(obj) = ty.as_object() {
        if let Some(_vec) = obj.get("vec") {
            quote! { Vec<u8> }  // Simplified - all vecs become Vec<u8>
        } else if let Some(option_inner) = obj.get("option") {
            if let Some(s) = option_inner.as_str() {
                match s {
                    "publicKey" => quote! { Option<[u8; 32]> },
                    _ => quote! { Option<Vec<u8>> },
                }
            } else {
                quote! { Option<Vec<u8>> }  // Default for complex option types
            }
        } else if let Some(_array) = obj.get("array") {
            quote! { Vec<u8> }  // Simplified - all arrays become Vec<u8>
        } else if let Some(_defined) = obj.get("defined") {
            quote! { Vec<u8> }  // Simplified - all custom types become Vec<u8>
        } else {
            quote! { Vec<u8> }
        }
    } else {
        quote! { Vec<u8> }
    }
} 