use crate :: pubkey_serializer :: pubkey_serde ; use crate :: pubkey_serializer :: pubkey_serde_option ; use serde :: Serializer ; # [allow (dead_code)] use std :: convert :: TryInto ; fn serialize_to_string < S , T > (x : & T , s : S) -> Result < S :: Ok , S :: Error > where S : Serializer , T : ToString { s . serialize_str (& x . to_string ()) } # [inline] fn read_u8 (mut d : & [u8]) -> anyhow :: Result < (u8 , & [u8]) > { if d . len () < 1 { anyhow :: bail ! ("EOF u8") } let v = d [0] ; Ok ((v , & d [1 ..])) } # [inline] fn read_bool (mut d : & [u8]) -> anyhow :: Result < (bool , & [u8]) > { let (b , rest) = read_u8 (d) ? ; Ok ((b != 0 , rest)) } # [inline] fn read_u16 (mut d : & [u8]) -> anyhow :: Result < (u16 , & [u8]) > { if d . len () < 2 { anyhow :: bail ! ("EOF u16") } let v = u16 :: from_le_bytes ([d [0] , d [1]]) ; Ok ((v , & d [2 ..])) } # [inline] fn read_u32 (mut d : & [u8]) -> anyhow :: Result < (u32 , & [u8]) > { if d . len () < 4 { anyhow :: bail ! ("EOF u32") } let v = u32 :: from_le_bytes (d [0 .. 4] . try_into () . unwrap ()) ; Ok ((v , & d [4 ..])) } # [inline] fn read_u64 (mut d : & [u8]) -> anyhow :: Result < (u64 , & [u8]) > { if d . len () < 8 { anyhow :: bail ! ("EOF u64") } let v = u64 :: from_le_bytes (d [0 .. 8] . try_into () . unwrap ()) ; Ok ((v , & d [8 ..])) } # [inline] fn read_i64 (mut d : & [u8]) -> anyhow :: Result < (i64 , & [u8]) > { if d . len () < 8 { anyhow :: bail ! ("EOF i64") } let v = i64 :: from_le_bytes (d [0 .. 8] . try_into () . unwrap ()) ; Ok ((v , & d [8 ..])) } # [inline] fn read_u128 (mut d : & [u8]) -> anyhow :: Result < (u128 , & [u8]) > { if d . len () < 16 { anyhow :: bail ! ("EOF u128") } let v = u128 :: from_le_bytes (d [0 .. 16] . try_into () . unwrap ()) ; Ok ((v , & d [16 ..])) } # [inline] fn read_pubkey (mut d : & [u8]) -> anyhow :: Result < ([u8 ; 32] , & [u8]) > { if d . len () < 32 { anyhow :: bail ! ("EOF pubkey") } let mut pk = [0u8 ; 32] ; pk . copy_from_slice (& d [.. 32]) ; Ok ((pk , & d [32 ..])) } # [inline] fn read_option_u128 (mut d : & [u8]) -> anyhow :: Result < (Option < u128 > , & [u8]) > { let (t , rest) = read_u8 (d) ? ; if t == 0 { Ok ((None , rest)) } else { let (v , rest2) = read_u128 (rest) ? ; Ok ((Some (v) , rest2)) } } # [inline] fn read_option_i64 (mut d : & [u8]) -> anyhow :: Result < (Option < i64 > , & [u8]) > { let (t , rest) = read_u8 (d) ? ; if t == 0 { Ok ((None , rest)) } else { let (v , rest2) = read_i64 (rest) ? ; Ok ((Some (v) , rest2)) } } pub mod types { use super :: * ; use serde :: Serialize ; # [derive (Debug , serde :: Serialize)] pub struct ActionFlagContainer { pub value : u8 , } impl ActionFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ActionHeader { pub version : u8 , pub action_state : u8 , pub bump : u8 , pub flags : ActionFlagContainer , pub callback_kind : u8 , pub callback_version : u8 , pub padding_0 : Vec < u8 > , pub id : u64 , pub store : [u8 ; 32] , pub market : [u8 ; 32] , pub owner : [u8 ; 32] , pub nonce : Vec < u8 > , pub max_execution_lamports : u64 , pub updated_at : i64 , pub updated_at_slot : u64 , pub creator : [u8 ; 32] , pub rent_receiver : [u8 ; 32] , pub receiver : [u8 ; 32] , pub callback_program_id : [u8 ; 32] , pub callback_shared_data : [u8 ; 32] , pub callback_partitioned_data : [u8 ; 32] , pub reserved : Vec < u8 > , } impl ActionHeader { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (action_state , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = ActionFlagContainer :: read (data) ? ; data = rest1 ; let (callback_kind , rest1) = read_u8 (data) ? ; data = rest1 ; let (callback_version , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (max_execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (updated_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (updated_at_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (creator , rest1) = read_pubkey (data) ? ; data = rest1 ; let (rent_receiver , rest1) = read_pubkey (data) ? ; data = rest1 ; let (receiver , rest1) = read_pubkey (data) ? ; data = rest1 ; let (callback_program_id , rest1) = read_pubkey (data) ? ; data = rest1 ; let (callback_shared_data , rest1) = read_pubkey (data) ? ; data = rest1 ; let (callback_partitioned_data , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , action_state , bump , flags , callback_kind , callback_version , padding_0 , id , store , market , owner , nonce , max_execution_lamports , updated_at , updated_at_slot , creator , rent_receiver , receiver , callback_program_id , callback_shared_data , callback_partitioned_data , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum ActionState { Pending , Completed , Cancelled } impl ActionState { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Pending , 1u8 => Self :: Completed , 2u8 => Self :: Cancelled , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (ActionState)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct Addresses { pub holding : [u8 ; 32] , pub reserved : Vec < u8 > , } impl Addresses { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (holding , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { holding , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Amounts { pub claimable_time_window : u64 , pub recent_time_window : u64 , pub request_expiration : u64 , pub oracle_max_age : u64 , pub oracle_max_timestamp_range : u64 , pub oracle_max_future_timestamp_excess : u64 , pub adl_prices_max_staleness : u64 , pub reserved : Vec < u8 > , } impl Amounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (claimable_time_window , rest1) = read_u64 (data) ? ; data = rest1 ; let (recent_time_window , rest1) = read_u64 (data) ? ; data = rest1 ; let (request_expiration , rest1) = read_u64 (data) ? ; data = rest1 ; let (oracle_max_age , rest1) = read_u64 (data) ? ; data = rest1 ; let (oracle_max_timestamp_range , rest1) = read_u64 (data) ? ; data = rest1 ; let (oracle_max_future_timestamp_excess , rest1) = read_u64 (data) ? ; data = rest1 ; let (adl_prices_max_staleness , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { claimable_time_window , recent_time_window , request_expiration , oracle_max_age , oracle_max_timestamp_range , oracle_max_future_timestamp_excess , adl_prices_max_staleness , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct BorrowingFees { pub fee_amount : Vec < u8 > , pub fee_amount_for_receiver : Vec < u8 > , } impl BorrowingFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { fee_amount , fee_amount_for_receiver } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct BorrowingFeesUpdated { pub rev : u64 , pub market_token : [u8 ; 32] , pub update_borrowing_state : UpdateBorrowingReport , } impl BorrowingFeesUpdated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (update_borrowing_state , rest1) = UpdateBorrowingReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , update_borrowing_state } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CallbackAuthority { pub bump_bytes : Vec < u8 > , } impl CallbackAuthority { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { bump_bytes } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ClaimableCollateral { pub output_token_amount : Vec < u8 > , pub secondary_output_token_amount : Vec < u8 > , } impl ClaimableCollateral { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { output_token_amount , secondary_output_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Clocks { pub padding : Vec < u8 > , pub rev : u64 , pub price_impact_distribution : i64 , pub borrowing : i64 , pub funding : i64 , pub adl_for_long : i64 , pub adl_for_short : i64 , pub reserved : Vec < u8 > , } impl Clocks { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (price_impact_distribution , rest1) = read_i64 (data) ? ; data = rest1 ; let (borrowing , rest1) = read_i64 (data) ? ; data = rest1 ; let (funding , rest1) = read_i64 (data) ? ; data = rest1 ; let (adl_for_long , rest1) = read_i64 (data) ? ; data = rest1 ; let (adl_for_short , rest1) = read_i64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { padding , rev , price_impact_distribution , borrowing , funding , adl_for_long , adl_for_short , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateDepositParams { pub execution_lamports : u64 , pub long_token_swap_length : u8 , pub short_token_swap_length : u8 , pub initial_long_token_amount : u64 , pub initial_short_token_amount : u64 , pub min_market_token_amount : u64 , pub should_unwrap_native_token : bool , } impl CreateDepositParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (initial_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (initial_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (should_unwrap_native_token , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , long_token_swap_length , short_token_swap_length , initial_long_token_amount , initial_short_token_amount , min_market_token_amount , should_unwrap_native_token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvDepositParams { pub execution_lamports : u64 , pub long_token_swap_length : u8 , pub short_token_swap_length : u8 , pub initial_long_token_amount : u64 , pub initial_short_token_amount : u64 , pub market_token_amount : u64 , pub min_market_token_amount : u64 , pub min_glv_token_amount : u64 , pub should_unwrap_native_token : bool , } impl CreateGlvDepositParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (initial_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (initial_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_glv_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (should_unwrap_native_token , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , long_token_swap_length , short_token_swap_length , initial_long_token_amount , initial_short_token_amount , market_token_amount , min_market_token_amount , min_glv_token_amount , should_unwrap_native_token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvWithdrawalParams { pub execution_lamports : u64 , pub long_token_swap_length : u8 , pub short_token_swap_length : u8 , pub glv_token_amount : u64 , pub min_final_long_token_amount : u64 , pub min_final_short_token_amount : u64 , pub should_unwrap_native_token : bool , } impl CreateGlvWithdrawalParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_token_swap_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (glv_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_final_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_final_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (should_unwrap_native_token , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , long_token_swap_length , short_token_swap_length , glv_token_amount , min_final_long_token_amount , min_final_short_token_amount , should_unwrap_native_token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateOrderParams { pub kind : OrderKind , pub decrease_position_swap_type : Option < DecreasePositionSwapType > , pub execution_lamports : u64 , pub swap_path_length : u8 , pub initial_collateral_delta_amount : u64 , pub size_delta_value : u128 , pub is_long : bool , pub is_collateral_long : bool , pub min_output : Option < u128 > , pub trigger_price : Option < u128 > , pub acceptable_price : Option < u128 > , pub should_unwrap_native_token : bool , pub valid_from_ts : Option < i64 > , } impl CreateOrderParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (kind , rest1) = OrderKind :: read (data) ? ; data = rest1 ; let (tag , r1) = read_u8 (data) ? ; data = r1 ; let decrease_position_swap_type = if tag == 0 { None } else { let (v , r2) = DecreasePositionSwapType :: read (data) ? ; data = r2 ; Some (v) } ; let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (swap_path_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (initial_collateral_delta_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (size_delta_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (is_long , rest1) = read_bool (data) ? ; data = rest1 ; let (is_collateral_long , rest1) = read_bool (data) ? ; data = rest1 ; let (min_output , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (trigger_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (acceptable_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (should_unwrap_native_token , rest1) = read_bool (data) ? ; data = rest1 ; let (valid_from_ts , rest1) = read_option_i64 (data) ? ; data = rest1 ; Ok ((Self { kind , decrease_position_swap_type , execution_lamports , swap_path_length , initial_collateral_delta_amount , size_delta_value , is_long , is_collateral_long , min_output , trigger_price , acceptable_price , should_unwrap_native_token , valid_from_ts } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateShiftParams { pub execution_lamports : u64 , pub from_market_token_amount : u64 , pub min_to_market_token_amount : u64 , } impl CreateShiftParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (from_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_to_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , from_market_token_amount , min_to_market_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateWithdrawalParams { pub execution_lamports : u64 , pub long_token_swap_path_length : u8 , pub short_token_swap_path_length : u8 , pub market_token_amount : u64 , pub min_long_token_amount : u64 , pub min_short_token_amount : u64 , pub should_unwrap_native_token : bool , } impl CreateWithdrawalParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_swap_path_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_token_swap_path_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (should_unwrap_native_token , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , long_token_swap_path_length , short_token_swap_path_length , market_token_amount , min_long_token_amount , min_short_token_amount , should_unwrap_native_token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DecreasePositionReport { pub price_impact_value : Vec < u8 > , pub price_impact_diff : Vec < u8 > , pub execution_price : Vec < u8 > , pub size_delta_in_tokens : Vec < u8 > , pub withdrawable_collateral_amount : Vec < u8 > , pub initial_size_delta_usd : Vec < u8 > , pub size_delta_usd : Vec < u8 > , pub fees : PositionFees , pub pnl : Pnl , pub insolvent_close_step : Option < InsolventCloseStep > , pub should_remove : bool , pub is_output_token_long : bool , pub is_secondary_output_token_long : bool , pub output_amounts : OutputAmounts , pub claimable_funding_long_token_amount : Vec < u8 > , pub claimable_funding_short_token_amount : Vec < u8 > , pub for_holding : ClaimableCollateral , pub for_user : ClaimableCollateral , } impl DecreasePositionReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (fees , rest1) = PositionFees :: read (data) ? ; data = rest1 ; let (pnl , rest1) = Pnl :: read (data) ? ; data = rest1 ; let (tag , r1) = read_u8 (data) ? ; data = r1 ; let insolvent_close_step = if tag == 0 { None } else { let (v , r2) = InsolventCloseStep :: read (data) ? ; data = r2 ; Some (v) } ; let (should_remove , rest1) = read_bool (data) ? ; data = rest1 ; let (is_output_token_long , rest1) = read_bool (data) ? ; data = rest1 ; let (is_secondary_output_token_long , rest1) = read_bool (data) ? ; data = rest1 ; let (output_amounts , rest1) = OutputAmounts :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (for_holding , rest1) = ClaimableCollateral :: read (data) ? ; data = rest1 ; let (for_user , rest1) = ClaimableCollateral :: read (data) ? ; data = rest1 ; Ok ((Self { price_impact_value , price_impact_diff , execution_price , size_delta_in_tokens , withdrawable_collateral_amount , initial_size_delta_usd , size_delta_usd , fees , pnl , insolvent_close_step , should_remove , is_output_token_long , is_secondary_output_token_long , output_amounts , claimable_funding_long_token_amount , claimable_funding_short_token_amount , for_holding , for_user } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum DecreasePositionSwapType { NoSwap , PnlTokenToCollateralToken , CollateralToPnlToken } impl DecreasePositionSwapType { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: NoSwap , 1u8 => Self :: PnlTokenToCollateralToken , 2u8 => Self :: CollateralToPnlToken , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (DecreasePositionSwapType)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct Deposit { pub header : ActionHeader , pub tokens : DepositTokenAccounts , pub params : DepositActionParams , pub swap : SwapActionParams , pub padding_0 : Vec < u8 > , pub reserved : Vec < u8 > , } impl Deposit { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (tokens , rest1) = DepositTokenAccounts :: read (data) ? ; data = rest1 ; let (params , rest1) = DepositActionParams :: read (data) ? ; data = rest1 ; let (swap , rest1) = SwapActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , tokens , params , swap , padding_0 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositActionParams { pub initial_long_token_amount : u64 , pub initial_short_token_amount : u64 , pub min_market_token_amount : u64 , pub reserved : Vec < u8 > , } impl DepositActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (initial_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (initial_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { initial_long_token_amount , initial_short_token_amount , min_market_token_amount , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositCreated { pub ts : i64 , pub store : [u8 ; 32] , pub deposit : [u8 ; 32] , } impl DepositCreated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (deposit , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { ts , store , deposit } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositExecuted { pub rev : u64 , pub market_token : [u8 ; 32] , pub report : DepositReport , } impl DepositExecuted { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (report , rest1) = DepositReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , report } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositParams { pub long_token_amount : Vec < u8 > , pub short_token_amount : Vec < u8 > , pub prices : Prices , } impl DepositParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; Ok ((Self { long_token_amount , short_token_amount , prices } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub deposit : [u8 ; 32] , pub market_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl DepositRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (deposit , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , deposit , market_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositReport { pub params : DepositParams , pub minted : Vec < u8 > , pub price_impact : Vec < u8 > , pub fees : Vec < u8 > , } impl DepositReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = DepositParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { params , minted , price_impact , fees } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DepositTokenAccounts { pub initial_long_token : TokenAndAccount , pub initial_short_token : TokenAndAccount , pub market_token : TokenAndAccount , pub reserved : Vec < u8 > , } impl DepositTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (initial_long_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (initial_short_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { initial_long_token , initial_short_token , market_token , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DisabledFeatures { pub map : DisabledMap , } impl DisabledFeatures { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (map , rest1) = DisabledMap :: read (data) ? ; data = rest1 ; Ok ((Self { map } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DisabledMap { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl DisabledMap { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DisabledMapEntry { pub key : Vec < u8 > , pub value : u8 , } impl DisabledMapEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DistributePositionImpactReport { pub duration_in_seconds : u64 , pub distribution_amount : Vec < u8 > , pub next_position_impact_pool_amount : Vec < u8 > , } impl DistributePositionImpactReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (duration_in_seconds , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { duration_in_seconds , distribution_amount , next_position_impact_pool_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Entry { pub key : u16 , pub value : u128 , } impl Entry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (key , rest1) = read_u16 (data) ? ; data = rest1 ; let (value , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EntryArgs { pub key : String , pub value : u128 , } impl EntryArgs { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (value , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventClocks { pub padding : Vec < u8 > , pub rev : u64 , pub price_impact_distribution : i64 , pub borrowing : i64 , pub funding : i64 , pub adl_for_long : i64 , pub adl_for_short : i64 , pub reserved : Vec < u8 > , } impl EventClocks { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (price_impact_distribution , rest1) = read_i64 (data) ? ; data = rest1 ; let (borrowing , rest1) = read_i64 (data) ? ; data = rest1 ; let (funding , rest1) = read_i64 (data) ? ; data = rest1 ; let (adl_for_long , rest1) = read_i64 (data) ? ; data = rest1 ; let (adl_for_short , rest1) = read_i64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { padding , rev , price_impact_distribution , borrowing , funding , adl_for_long , adl_for_short , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventOtherState { pub padding : Vec < u8 > , pub rev : u64 , pub trade_count : u64 , pub long_token_balance : u64 , pub short_token_balance : u64 , pub funding_factor_per_second : i128 , pub reserved : Vec < u8 > , } impl EventOtherState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (trade_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_balance , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_balance , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { padding , rev , trade_count , long_token_balance , short_token_balance , funding_factor_per_second , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventPool { pub is_pure : u8 , pub padding : Vec < u8 > , pub long_token_amount : u128 , pub short_token_amount : u128 , } impl EventPool { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (is_pure , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (long_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (short_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { is_pure , padding , long_token_amount , short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventPositionState { pub trade_id : u64 , pub increased_at : i64 , pub updated_at_slot : u64 , pub decreased_at : i64 , pub size_in_tokens : u128 , pub collateral_amount : u128 , pub size_in_usd : u128 , pub borrowing_factor : u128 , pub funding_fee_amount_per_size : u128 , pub long_token_claimable_funding_amount_per_size : u128 , pub short_token_claimable_funding_amount_per_size : u128 , pub reserved : Vec < u8 > , } impl EventPositionState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (trade_id , rest1) = read_u64 (data) ? ; data = rest1 ; let (increased_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (updated_at_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (decreased_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (size_in_tokens , rest1) = read_u128 (data) ? ; data = rest1 ; let (collateral_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (size_in_usd , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; let (long_token_claimable_funding_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; let (short_token_claimable_funding_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { trade_id , increased_at , updated_at_slot , decreased_at , size_in_tokens , collateral_amount , size_in_usd , borrowing_factor , funding_fee_amount_per_size , long_token_claimable_funding_amount_per_size , short_token_claimable_funding_amount_per_size , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTradeFees { pub order_fee_for_receiver_amount : u128 , pub order_fee_for_pool_amount : u128 , pub liquidation_fee_amount : u128 , pub liquidation_fee_for_receiver_amount : u128 , pub total_borrowing_fee_amount : u128 , pub borrowing_fee_for_receiver_amount : u128 , pub funding_fee_amount : u128 , pub claimable_funding_fee_long_token_amount : u128 , pub claimable_funding_fee_short_token_amount : u128 , } impl EventTradeFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (order_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_for_pool_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (total_borrowing_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (claimable_funding_fee_long_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (claimable_funding_fee_short_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { order_fee_for_receiver_amount , order_fee_for_pool_amount , liquidation_fee_amount , liquidation_fee_for_receiver_amount , total_borrowing_fee_amount , borrowing_fee_for_receiver_amount , funding_fee_amount , claimable_funding_fee_long_token_amount , claimable_funding_fee_short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTradeOutputAmounts { pub output_amount : u128 , pub secondary_output_amount : u128 , } impl EventTradeOutputAmounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (output_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (secondary_output_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { output_amount , secondary_output_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTradePnl { pub pnl : i128 , pub uncapped_pnl : i128 , } impl EventTradePnl { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; Ok ((Self { pnl , uncapped_pnl } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTradePrice { pub min : u128 , pub max : u128 , } impl EventTradePrice { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (min , rest1) = read_u128 (data) ? ; data = rest1 ; let (max , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { min , max } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTradePrices { pub index : EventTradePrice , pub long : EventTradePrice , pub short : EventTradePrice , } impl EventTradePrices { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = EventTradePrice :: read (data) ? ; data = rest1 ; let (long , rest1) = EventTradePrice :: read (data) ? ; data = rest1 ; let (short , rest1) = EventTradePrice :: read (data) ? ; data = rest1 ; Ok ((Self { index , long , short } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EventTransferOut { pub executed : u8 , pub padding_0 : Vec < u8 > , pub final_output_token : u64 , pub secondary_output_token : u64 , pub long_token : u64 , pub short_token : u64 , pub long_token_for_claimable_account_of_user : u64 , pub short_token_for_claimable_account_of_user : u64 , pub long_token_for_claimable_account_of_holding : u64 , pub short_token_for_claimable_account_of_holding : u64 , } impl EventTransferOut { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (executed , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (final_output_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (secondary_output_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_for_claimable_account_of_user , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_for_claimable_account_of_user , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_for_claimable_account_of_holding , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_for_claimable_account_of_holding , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { executed , padding_0 , final_output_token , secondary_output_token , long_token , short_token , long_token_for_claimable_account_of_user , short_token_for_claimable_account_of_user , long_token_for_claimable_account_of_holding , short_token_for_claimable_account_of_holding } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecutionParams { pub price_impact_value : Vec < u8 > , pub price_impact_amount : Vec < u8 > , pub size_delta_in_tokens : Vec < u8 > , pub execution_price : Vec < u8 > , } impl ExecutionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { price_impact_value , price_impact_amount , size_delta_in_tokens , execution_price } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Factors { pub oracle_ref_price_deviation : u128 , pub order_fee_discount_for_referred_user : u128 , pub reserved : Vec < u8 > , } impl Factors { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (oracle_ref_price_deviation , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_discount_for_referred_user , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { oracle_ref_price_deviation , order_fee_discount_for_referred_user , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Fees { pub fee_amount_for_receiver : Vec < u8 > , pub fee_amount_for_pool : Vec < u8 > , } impl Fees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { fee_amount_for_receiver , fee_amount_for_pool } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct FundingFees { pub amount : Vec < u8 > , pub claimable_long_token_amount : Vec < u8 > , pub claimable_short_token_amount : Vec < u8 > , } impl FundingFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { amount , claimable_long_token_amount , claimable_short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Glv { pub version : u8 , pub bump : u8 , pub bump_bytes : Vec < u8 > , pub padding_0 : Vec < u8 > , pub index : u16 , pub store : [u8 ; 32] , pub glv_token : [u8 ; 32] , pub long_token : [u8 ; 32] , pub short_token : [u8 ; 32] , pub shift_last_executed_at : i64 , pub min_tokens_for_first_deposit : u64 , pub shift_min_interval_secs : u32 , pub padding_1 : Vec < u8 > , pub shift_max_price_impact_factor : u128 , pub shift_min_value : u128 , pub reserved : Vec < u8 > , pub markets : GlvMarkets , } impl Glv { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (index , rest1) = read_u16 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (glv_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (long_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (short_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (shift_last_executed_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (min_tokens_for_first_deposit , rest1) = read_u64 (data) ? ; data = rest1 ; let (shift_min_interval_secs , rest1) = read_u32 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (shift_max_price_impact_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (shift_min_value , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (markets , rest1) = GlvMarkets :: read (data) ? ; data = rest1 ; Ok ((Self { version , bump , bump_bytes , padding_0 , index , store , glv_token , long_token , short_token , shift_last_executed_at , min_tokens_for_first_deposit , shift_min_interval_secs , padding_1 , shift_max_price_impact_factor , shift_min_value , reserved , markets } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvDeposit { pub header : ActionHeader , pub tokens : GlvDepositTokenAccounts , pub params : GlvDepositActionParams , pub swap : SwapActionParams , pub padding_1 : Vec < u8 > , pub reserved : Vec < u8 > , } impl GlvDeposit { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (tokens , rest1) = GlvDepositTokenAccounts :: read (data) ? ; data = rest1 ; let (params , rest1) = GlvDepositActionParams :: read (data) ? ; data = rest1 ; let (swap , rest1) = SwapActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , tokens , params , swap , padding_1 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvDepositActionParams { pub deposit : DepositActionParams , pub market_token_amount : u64 , pub min_glv_token_amount : u64 , pub reserved : Vec < u8 > , } impl GlvDepositActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (deposit , rest1) = DepositActionParams :: read (data) ? ; data = rest1 ; let (market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_glv_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { deposit , market_token_amount , min_glv_token_amount , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvDepositRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub glv_deposit : [u8 ; 32] , pub market_token : [u8 ; 32] , pub glv_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl GlvDepositRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (glv_deposit , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (glv_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , glv_deposit , market_token , glv_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvDepositTokenAccounts { pub initial_long_token : TokenAndAccount , pub initial_short_token : TokenAndAccount , pub market_token : TokenAndAccount , pub glv_token : TokenAndAccount , pub reserved : Vec < u8 > , } impl GlvDepositTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (initial_long_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (initial_short_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (glv_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { initial_long_token , initial_short_token , market_token , glv_token , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvMarketConfig { pub max_amount : u64 , pub flags : GlvMarketFlagContainer , pub padding_0 : Vec < u8 > , pub max_value : u128 , pub balance : u64 , pub padding_1 : Vec < u8 > , } impl GlvMarketConfig { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (max_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (flags , rest1) = GlvMarketFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (max_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (balance , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { max_amount , flags , padding_0 , max_value , balance , padding_1 } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvMarketFlagContainer { pub value : u8 , } impl GlvMarketFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvMarkets { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl GlvMarkets { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvMarketsEntry { pub key : Vec < u8 > , pub value : GlvMarketConfig , } impl GlvMarketsEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = GlvMarketConfig :: read (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvPricing { pub glv_token : [u8 ; 32] , pub market_token : [u8 ; 32] , pub supply : u64 , pub is_value_maximized : bool , pub value : u128 , pub input_amount : u64 , pub input_value : u128 , pub output_amount : u64 , pub kind : GlvPricingKind , } impl GlvPricing { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (glv_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (supply , rest1) = read_u64 (data) ? ; data = rest1 ; let (is_value_maximized , rest1) = read_bool (data) ? ; data = rest1 ; let (value , rest1) = read_u128 (data) ? ; data = rest1 ; let (input_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (input_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (output_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (kind , rest1) = GlvPricingKind :: read (data) ? ; data = rest1 ; Ok ((Self { glv_token , market_token , supply , is_value_maximized , value , input_amount , input_value , output_amount , kind } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum GlvPricingKind { Deposit , Withdrawal } impl GlvPricingKind { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Deposit , 1u8 => Self :: Withdrawal , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (GlvPricingKind)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvShift { pub shift : Shift , pub reserved : Vec < u8 > , } impl GlvShift { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (shift , rest1) = Shift :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { shift , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvWithdrawal { pub header : ActionHeader , pub tokens : GlvWithdrawalTokenAccounts , pub params : GlvWithdrawalActionParams , pub swap : SwapActionParams , pub padding_1 : Vec < u8 > , pub reserved : Vec < u8 > , } impl GlvWithdrawal { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (tokens , rest1) = GlvWithdrawalTokenAccounts :: read (data) ? ; data = rest1 ; let (params , rest1) = GlvWithdrawalActionParams :: read (data) ? ; data = rest1 ; let (swap , rest1) = SwapActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , tokens , params , swap , padding_1 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvWithdrawalActionParams { pub glv_token_amount : u64 , pub min_final_long_token_amount : u64 , pub min_final_short_token_amount : u64 , pub reserved : Vec < u8 > , } impl GlvWithdrawalActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (glv_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_final_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_final_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { glv_token_amount , min_final_long_token_amount , min_final_short_token_amount , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvWithdrawalRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub glv_withdrawal : [u8 ; 32] , pub market_token : [u8 ; 32] , pub glv_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl GlvWithdrawalRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (glv_withdrawal , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (glv_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , glv_withdrawal , market_token , glv_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GlvWithdrawalTokenAccounts { pub final_long_token : TokenAndAccount , pub final_short_token : TokenAndAccount , pub market_token : TokenAndAccount , pub glv_token : TokenAndAccount , pub reserved : Vec < u8 > , } impl GlvWithdrawalTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (final_long_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (final_short_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (glv_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { final_long_token , final_short_token , market_token , glv_token , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtBuyback { pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub gt_exchange_vault : [u8 ; 32] , pub authority : [u8 ; 32] , pub buyback_amount : u64 , pub buyback_value : Option < u128 > , pub buyback_price : Option < u128 > , } impl GtBuyback { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (gt_exchange_vault , rest1) = read_pubkey (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (buyback_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (buyback_value , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (buyback_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; Ok ((Self { ts , slot , store , gt_exchange_vault , authority , buyback_amount , buyback_value , buyback_price } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtExchange { pub bump : u8 , pub flags : GtExchangeFlagContainer , pub padding : Vec < u8 > , pub amount : u64 , pub owner : [u8 ; 32] , pub store : [u8 ; 32] , pub vault : [u8 ; 32] , pub reserved : Vec < u8 > , } impl GtExchange { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = GtExchangeFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (vault , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { bump , flags , padding , amount , owner , store , vault , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtExchangeFlagContainer { pub value : u8 , } impl GtExchangeFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtExchangeVault { pub bump : u8 , pub flags : GtExchangeVaultFlagContainer , pub padding : Vec < u8 > , pub ts : i64 , pub time_window : i64 , pub amount : u64 , pub store : [u8 ; 32] , pub reserved : Vec < u8 > , } impl GtExchangeVault { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = GtExchangeVaultFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (time_window , rest1) = read_i64 (data) ? ; data = rest1 ; let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { bump , flags , padding , ts , time_window , amount , store , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtExchangeVaultFlagContainer { pub value : u8 , } impl GtExchangeVaultFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtState { pub decimals : u8 , pub padding_0 : Vec < u8 > , pub last_minted_at : i64 , pub total_minted : u64 , pub grow_step_amount : u64 , pub grow_steps : u64 , pub supply : u64 , pub padding_1 : Vec < u8 > , pub gt_vault : u64 , pub padding_2 : Vec < u8 > , pub minting_cost_grow_factor : u128 , pub minting_cost : u128 , pub padding_3 : Vec < u8 > , pub exchange_time_window : u32 , pub padding_4 : Vec < u8 > , pub max_rank : u64 , pub ranks : Vec < u8 > , pub order_fee_discount_factors : Vec < u8 > , pub referral_reward_factors : Vec < u8 > , pub padding_5 : Vec < u8 > , pub reserved : Vec < u8 > , } impl GtState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (decimals , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (last_minted_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (total_minted , rest1) = read_u64 (data) ? ; data = rest1 ; let (grow_step_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (grow_steps , rest1) = read_u64 (data) ? ; data = rest1 ; let (supply , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (gt_vault , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (minting_cost_grow_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (minting_cost , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (exchange_time_window , rest1) = read_u32 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (max_rank , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { decimals , padding_0 , last_minted_at , total_minted , grow_step_amount , grow_steps , supply , padding_1 , gt_vault , padding_2 , minting_cost_grow_factor , minting_cost , padding_3 , exchange_time_window , padding_4 , max_rank , ranks , order_fee_discount_factors , referral_reward_factors , padding_5 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum GtUpdateKind { Reward , Mint , Burn } impl GtUpdateKind { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Reward , 1u8 => Self :: Mint , 2u8 => Self :: Burn , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (GtUpdateKind)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct GtUpdated { pub kind : GtUpdateKind , pub receiver : Option < [u8 ; 32] > , pub receiver_delta : u64 , pub receiver_balance : Option < u64 > , pub minting_cost : u128 , pub total_minted : u64 , pub grow_steps : u64 , pub supply : u64 , pub vault : u64 , pub reserved : Vec < u8 > , } impl GtUpdated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (kind , rest1) = GtUpdateKind :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; let (receiver_delta , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; let (minting_cost , rest1) = read_u128 (data) ? ; data = rest1 ; let (total_minted , rest1) = read_u64 (data) ? ; data = rest1 ; let (grow_steps , rest1) = read_u64 (data) ? ; data = rest1 ; let (supply , rest1) = read_u64 (data) ? ; data = rest1 ; let (vault , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { kind , receiver , receiver_delta , receiver_balance , minting_cost , total_minted , grow_steps , supply , vault , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct IncreasePositionParams { pub collateral_increment_amount : Vec < u8 > , pub size_delta_usd : Vec < u8 > , pub acceptable_price : Option < Vec < u8 > > , pub prices : Prices , } impl IncreasePositionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; Ok ((Self { collateral_increment_amount , size_delta_usd , acceptable_price , prices } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct IncreasePositionReport { pub params : IncreasePositionParams , pub execution : ExecutionParams , pub collateral_delta_amount : Vec < u8 > , pub fees : PositionFees , pub claimable_funding_long_token_amount : Vec < u8 > , pub claimable_funding_short_token_amount : Vec < u8 > , } impl IncreasePositionReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = IncreasePositionParams :: read (data) ? ; data = rest1 ; let (execution , rest1) = ExecutionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (fees , rest1) = PositionFees :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { params , execution , collateral_delta_amount , fees , claimable_funding_long_token_amount , claimable_funding_short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Indexer { pub trade_count : u64 , pub deposit_count : u64 , pub withdrawal_count : u64 , pub order_count : u64 , pub shift_count : u64 , pub glv_deposit_count : u64 , pub glv_withdrawal_count : u64 , pub padding_0 : Vec < u8 > , pub reserved : Vec < u8 > , } impl Indexer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (trade_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (deposit_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (withdrawal_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (order_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (shift_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (glv_deposit_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (glv_withdrawal_count , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { trade_count , deposit_count , withdrawal_count , order_count , shift_count , glv_deposit_count , glv_withdrawal_count , padding_0 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum InsolventCloseStep { Pnl , Fees , Funding , Impact , Diff } impl InsolventCloseStep { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Pnl , 1u8 => Self :: Fees , 2u8 => Self :: Funding , 3u8 => Self :: Impact , 4u8 => Self :: Diff , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (InsolventCloseStep)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct InsufficientFundingFeePayment { pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub market_token : [u8 ; 32] , pub cost_amount : u128 , pub paid_in_collateral_amount : u128 , pub paid_in_secondary_output_amount : u128 , pub is_collateral_token_long : bool , } impl InsufficientFundingFeePayment { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (cost_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (paid_in_collateral_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (paid_in_secondary_output_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (is_collateral_token_long , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { ts , slot , store , market_token , cost_amount , paid_in_collateral_amount , paid_in_secondary_output_amount , is_collateral_token_long } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct LiquidationFees { pub fee_value : Vec < u8 > , pub fee_amount : Vec < u8 > , pub fee_amount_for_receiver : Vec < u8 > , } impl LiquidationFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { fee_value , fee_amount , fee_amount_for_receiver } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Market { pub version : u8 , pub bump : u8 , pub flags : MarketFlagContainer , pub padding : Vec < u8 > , pub name : Vec < u8 > , pub meta : MarketMeta , pub store : [u8 ; 32] , pub config : MarketConfig , pub indexer : Indexer , pub state : State , pub buffer : RevertibleBuffer , pub virtual_inventory_for_swaps : [u8 ; 32] , pub virtual_inventory_for_positions : [u8 ; 32] , pub reserved : Vec < u8 > , } impl Market { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = MarketFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (meta , rest1) = MarketMeta :: read (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (config , rest1) = MarketConfig :: read (data) ? ; data = rest1 ; let (indexer , rest1) = Indexer :: read (data) ? ; data = rest1 ; let (state , rest1) = State :: read (data) ? ; data = rest1 ; let (buffer , rest1) = RevertibleBuffer :: read (data) ? ; data = rest1 ; let (virtual_inventory_for_swaps , rest1) = read_pubkey (data) ? ; data = rest1 ; let (virtual_inventory_for_positions , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , flags , padding , name , meta , store , config , indexer , state , buffer , virtual_inventory_for_swaps , virtual_inventory_for_positions , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketConfig { pub flag : MarketConfigFlagContainer , pub swap_impact_exponent : u128 , pub swap_impact_positive_factor : u128 , pub swap_impact_negative_factor : u128 , pub swap_fee_receiver_factor : u128 , pub swap_fee_factor_for_positive_impact : u128 , pub swap_fee_factor_for_negative_impact : u128 , pub min_position_size_usd : u128 , pub min_collateral_value : u128 , pub min_collateral_factor : u128 , pub min_collateral_factor_for_open_interest_multiplier_for_long : u128 , pub min_collateral_factor_for_open_interest_multiplier_for_short : u128 , pub max_positive_position_impact_factor : u128 , pub max_negative_position_impact_factor : u128 , pub max_position_impact_factor_for_liquidations : u128 , pub position_impact_exponent : u128 , pub position_impact_positive_factor : u128 , pub position_impact_negative_factor : u128 , pub order_fee_receiver_factor : u128 , pub order_fee_factor_for_positive_impact : u128 , pub order_fee_factor_for_negative_impact : u128 , pub liquidation_fee_receiver_factor : u128 , pub liquidation_fee_factor : u128 , pub position_impact_distribute_factor : u128 , pub min_position_impact_pool_amount : u128 , pub borrowing_fee_receiver_factor : u128 , pub borrowing_fee_factor_for_long : u128 , pub borrowing_fee_factor_for_short : u128 , pub borrowing_fee_exponent_for_long : u128 , pub borrowing_fee_exponent_for_short : u128 , pub borrowing_fee_optimal_usage_factor_for_long : u128 , pub borrowing_fee_optimal_usage_factor_for_short : u128 , pub borrowing_fee_base_factor_for_long : u128 , pub borrowing_fee_base_factor_for_short : u128 , pub borrowing_fee_above_optimal_usage_factor_for_long : u128 , pub borrowing_fee_above_optimal_usage_factor_for_short : u128 , pub funding_fee_exponent : u128 , pub funding_fee_factor : u128 , pub funding_fee_max_factor_per_second : u128 , pub funding_fee_min_factor_per_second : u128 , pub funding_fee_increase_factor_per_second : u128 , pub funding_fee_decrease_factor_per_second : u128 , pub funding_fee_threshold_for_stable_funding : u128 , pub funding_fee_threshold_for_decrease_funding : u128 , pub reserve_factor : u128 , pub open_interest_reserve_factor : u128 , pub max_pnl_factor_for_long_deposit : u128 , pub max_pnl_factor_for_short_deposit : u128 , pub max_pnl_factor_for_long_withdrawal : u128 , pub max_pnl_factor_for_short_withdrawal : u128 , pub max_pnl_factor_for_long_trader : u128 , pub max_pnl_factor_for_short_trader : u128 , pub max_pnl_factor_for_long_adl : u128 , pub max_pnl_factor_for_short_adl : u128 , pub min_pnl_factor_after_long_adl : u128 , pub min_pnl_factor_after_short_adl : u128 , pub max_pool_amount_for_long_token : u128 , pub max_pool_amount_for_short_token : u128 , pub max_pool_value_for_deposit_for_long_token : u128 , pub max_pool_value_for_deposit_for_short_token : u128 , pub max_open_interest_for_long : u128 , pub max_open_interest_for_short : u128 , pub min_tokens_for_first_deposit : u128 , pub reserved : Vec < u8 > , } impl MarketConfig { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (flag , rest1) = MarketConfigFlagContainer :: read (data) ? ; data = rest1 ; let (swap_impact_exponent , rest1) = read_u128 (data) ? ; data = rest1 ; let (swap_impact_positive_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (swap_impact_negative_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (swap_fee_receiver_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (swap_fee_factor_for_positive_impact , rest1) = read_u128 (data) ? ; data = rest1 ; let (swap_fee_factor_for_negative_impact , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_position_size_usd , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_collateral_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_collateral_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_collateral_factor_for_open_interest_multiplier_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_collateral_factor_for_open_interest_multiplier_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_positive_position_impact_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_negative_position_impact_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_position_impact_factor_for_liquidations , rest1) = read_u128 (data) ? ; data = rest1 ; let (position_impact_exponent , rest1) = read_u128 (data) ? ; data = rest1 ; let (position_impact_positive_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (position_impact_negative_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_receiver_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_factor_for_positive_impact , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_factor_for_negative_impact , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_receiver_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (position_impact_distribute_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_position_impact_pool_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_receiver_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_factor_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_factor_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_exponent_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_exponent_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_optimal_usage_factor_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_optimal_usage_factor_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_base_factor_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_base_factor_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_above_optimal_usage_factor_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_above_optimal_usage_factor_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_exponent , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_max_factor_per_second , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_min_factor_per_second , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_increase_factor_per_second , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_decrease_factor_per_second , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_threshold_for_stable_funding , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_threshold_for_decrease_funding , rest1) = read_u128 (data) ? ; data = rest1 ; let (reserve_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (open_interest_reserve_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_long_deposit , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_short_deposit , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_long_withdrawal , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_short_withdrawal , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_long_trader , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_short_trader , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_long_adl , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pnl_factor_for_short_adl , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_pnl_factor_after_long_adl , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_pnl_factor_after_short_adl , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pool_amount_for_long_token , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pool_amount_for_short_token , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pool_value_for_deposit_for_long_token , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_pool_value_for_deposit_for_short_token , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_open_interest_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_open_interest_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_tokens_for_first_deposit , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { flag , swap_impact_exponent , swap_impact_positive_factor , swap_impact_negative_factor , swap_fee_receiver_factor , swap_fee_factor_for_positive_impact , swap_fee_factor_for_negative_impact , min_position_size_usd , min_collateral_value , min_collateral_factor , min_collateral_factor_for_open_interest_multiplier_for_long , min_collateral_factor_for_open_interest_multiplier_for_short , max_positive_position_impact_factor , max_negative_position_impact_factor , max_position_impact_factor_for_liquidations , position_impact_exponent , position_impact_positive_factor , position_impact_negative_factor , order_fee_receiver_factor , order_fee_factor_for_positive_impact , order_fee_factor_for_negative_impact , liquidation_fee_receiver_factor , liquidation_fee_factor , position_impact_distribute_factor , min_position_impact_pool_amount , borrowing_fee_receiver_factor , borrowing_fee_factor_for_long , borrowing_fee_factor_for_short , borrowing_fee_exponent_for_long , borrowing_fee_exponent_for_short , borrowing_fee_optimal_usage_factor_for_long , borrowing_fee_optimal_usage_factor_for_short , borrowing_fee_base_factor_for_long , borrowing_fee_base_factor_for_short , borrowing_fee_above_optimal_usage_factor_for_long , borrowing_fee_above_optimal_usage_factor_for_short , funding_fee_exponent , funding_fee_factor , funding_fee_max_factor_per_second , funding_fee_min_factor_per_second , funding_fee_increase_factor_per_second , funding_fee_decrease_factor_per_second , funding_fee_threshold_for_stable_funding , funding_fee_threshold_for_decrease_funding , reserve_factor , open_interest_reserve_factor , max_pnl_factor_for_long_deposit , max_pnl_factor_for_short_deposit , max_pnl_factor_for_long_withdrawal , max_pnl_factor_for_short_withdrawal , max_pnl_factor_for_long_trader , max_pnl_factor_for_short_trader , max_pnl_factor_for_long_adl , max_pnl_factor_for_short_adl , min_pnl_factor_after_long_adl , min_pnl_factor_after_short_adl , max_pool_amount_for_long_token , max_pool_amount_for_short_token , max_pool_value_for_deposit_for_long_token , max_pool_value_for_deposit_for_short_token , max_open_interest_for_long , max_open_interest_for_short , min_tokens_for_first_deposit , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketConfigBuffer { pub store : [u8 ; 32] , pub authority : [u8 ; 32] , pub expiry : i64 , pub entries : Vec < u8 > , } impl MarketConfigBuffer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (expiry , rest1) = read_i64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { store , authority , expiry , entries } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketConfigFlagContainer { pub value : u128 , } impl MarketConfigFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketFeesUpdated { pub rev : u64 , pub market_token : [u8 ; 32] , pub position_impact_distribution : DistributePositionImpactReport , pub update_borrowing_state : UpdateBorrowingReport , pub update_funding_state : UpdateFundingReport , } impl MarketFeesUpdated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (position_impact_distribution , rest1) = DistributePositionImpactReport :: read (data) ? ; data = rest1 ; let (update_borrowing_state , rest1) = UpdateBorrowingReport :: read (data) ? ; data = rest1 ; let (update_funding_state , rest1) = UpdateFundingReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , position_impact_distribution , update_borrowing_state , update_funding_state } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketFlagContainer { pub value : u8 , } impl MarketFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketMeta { pub market_token_mint : [u8 ; 32] , pub index_token_mint : [u8 ; 32] , pub long_token_mint : [u8 ; 32] , pub short_token_mint : [u8 ; 32] , } impl MarketMeta { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (market_token_mint , rest1) = read_pubkey (data) ? ; data = rest1 ; let (index_token_mint , rest1) = read_pubkey (data) ? ; data = rest1 ; let (long_token_mint , rest1) = read_pubkey (data) ? ; data = rest1 ; let (short_token_mint , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { market_token_mint , index_token_mint , long_token_mint , short_token_mint } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketStateUpdated { pub rev : u64 , pub market_token : [u8 ; 32] , pub pool_kinds : Vec < u8 > , pub pools : Vec < u8 > , pub clocks : Vec < u8 > , pub other : Vec < u8 > , } impl MarketStateUpdated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { rev , market_token , pool_kinds , pools , clocks , other } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketStatus { pub funding_factor_per_second : i128 , pub borrowing_factor_per_second_for_long : u128 , pub borrowing_factor_per_second_for_short : u128 , pub pending_pnl_for_long : i128 , pub pending_pnl_for_short : i128 , pub reserve_value_for_long : u128 , pub reserve_value_for_short : u128 , pub pool_value_without_pnl_for_long : u128 , pub pool_value_without_pnl_for_short : u128 , } impl MarketStatus { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; let (borrowing_factor_per_second_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_factor_per_second_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; let (reserve_value_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (reserve_value_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; let (pool_value_without_pnl_for_long , rest1) = read_u128 (data) ? ; data = rest1 ; let (pool_value_without_pnl_for_short , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { funding_factor_per_second , borrowing_factor_per_second_for_long , borrowing_factor_per_second_for_short , pending_pnl_for_long , pending_pnl_for_short , reserve_value_for_long , reserve_value_for_short , pool_value_without_pnl_for_long , pool_value_without_pnl_for_short } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Members { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl Members { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MembersEntry { pub key : Vec < u8 > , pub value : u32 , } impl MembersEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Oracle { pub version : u8 , pub padding_0 : Vec < u8 > , pub store : [u8 ; 32] , pub authority : [u8 ; 32] , pub min_oracle_ts : i64 , pub max_oracle_ts : i64 , pub min_oracle_slot : u64 , pub primary : PriceMap , pub flags : OracleFlagContainer , pub padding_1 : Vec < u8 > , pub reserved : Vec < u8 > , } impl Oracle { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (min_oracle_ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (max_oracle_ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (min_oracle_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (primary , rest1) = PriceMap :: read (data) ? ; data = rest1 ; let (flags , rest1) = OracleFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , padding_0 , store , authority , min_oracle_ts , max_oracle_ts , min_oracle_slot , primary , flags , padding_1 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OracleFlagContainer { pub value : u8 , } impl OracleFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Order { pub header : ActionHeader , pub market_token : [u8 ; 32] , pub tokens : OrderTokenAccounts , pub swap : SwapActionParams , pub padding_0 : Vec < u8 > , pub params : OrderActionParams , pub gt_reward : u64 , pub padding_1 : Vec < u8 > , pub reserved : Vec < u8 > , } impl Order { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (tokens , rest1) = OrderTokenAccounts :: read (data) ? ; data = rest1 ; let (swap , rest1) = SwapActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = OrderActionParams :: read (data) ? ; data = rest1 ; let (gt_reward , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , market_token , tokens , swap , padding_0 , params , gt_reward , padding_1 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderActionParams { pub kind : u8 , pub side : u8 , pub decrease_position_swap_type : u8 , pub padding_1 : Vec < u8 > , pub collateral_token : [u8 ; 32] , pub position : [u8 ; 32] , pub initial_collateral_delta_amount : u64 , pub size_delta_value : u128 , pub min_output : u128 , pub trigger_price : u128 , pub acceptable_price : u128 , pub valid_from_ts : i64 , pub padding_2 : Vec < u8 > , pub reserved : Vec < u8 > , } impl OrderActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (kind , rest1) = read_u8 (data) ? ; data = rest1 ; let (side , rest1) = read_u8 (data) ? ; data = rest1 ; let (decrease_position_swap_type , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (collateral_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (position , rest1) = read_pubkey (data) ? ; data = rest1 ; let (initial_collateral_delta_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (size_delta_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_output , rest1) = read_u128 (data) ? ; data = rest1 ; let (trigger_price , rest1) = read_u128 (data) ? ; data = rest1 ; let (acceptable_price , rest1) = read_u128 (data) ? ; data = rest1 ; let (valid_from_ts , rest1) = read_i64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { kind , side , decrease_position_swap_type , padding_1 , collateral_token , position , initial_collateral_delta_amount , size_delta_value , min_output , trigger_price , acceptable_price , valid_from_ts , padding_2 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderCreated { pub ts : i64 , pub store : [u8 ; 32] , pub order : [u8 ; 32] , pub position : Option < [u8 ; 32] > , } impl OrderCreated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (order , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; Ok ((Self { ts , store , order , position } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderFees { pub base : Fees , pub fee_value : Vec < u8 > , } impl OrderFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (base , rest1) = Fees :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { base , fee_value } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum OrderKind { Liquidation , AutoDeleveraging , MarketSwap , MarketIncrease , MarketDecrease , LimitSwap , LimitIncrease , LimitDecrease , StopLossDecrease } impl OrderKind { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Liquidation , 1u8 => Self :: AutoDeleveraging , 2u8 => Self :: MarketSwap , 3u8 => Self :: MarketIncrease , 4u8 => Self :: MarketDecrease , 5u8 => Self :: LimitSwap , 6u8 => Self :: LimitIncrease , 7u8 => Self :: LimitDecrease , 8u8 => Self :: StopLossDecrease , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (OrderKind)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderParamsForEvent { pub kind : OrderKind , pub is_long : bool , pub decrease_position_swap_type : DecreasePositionSwapType , pub position : Option < [u8 ; 32] > , pub collateral_token : [u8 ; 32] , pub initial_collateral_token : Option < [u8 ; 32] > , pub initial_collateral_delta_amount : u64 , pub size_delta_value : u128 , pub min_output : u128 , pub trigger_price : u128 , pub acceptable_price : u128 , pub valid_from_ts : i64 , } impl OrderParamsForEvent { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (kind , rest1) = OrderKind :: read (data) ? ; data = rest1 ; let (is_long , rest1) = read_bool (data) ? ; data = rest1 ; let (decrease_position_swap_type , rest1) = DecreasePositionSwapType :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; let (collateral_token , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; let (initial_collateral_delta_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (size_delta_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_output , rest1) = read_u128 (data) ? ; data = rest1 ; let (trigger_price , rest1) = read_u128 (data) ? ; data = rest1 ; let (acceptable_price , rest1) = read_u128 (data) ? ; data = rest1 ; let (valid_from_ts , rest1) = read_i64 (data) ? ; data = rest1 ; Ok ((Self { kind , is_long , decrease_position_swap_type , position , collateral_token , initial_collateral_token , initial_collateral_delta_amount , size_delta_value , min_output , trigger_price , acceptable_price , valid_from_ts } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub order : [u8 ; 32] , pub kind : OrderKind , pub market_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl OrderRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (order , rest1) = read_pubkey (data) ? ; data = rest1 ; let (kind , rest1) = OrderKind :: read (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , order , kind , market_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderTokenAccounts { pub initial_collateral : TokenAndAccount , pub final_output_token : TokenAndAccount , pub long_token : TokenAndAccount , pub short_token : TokenAndAccount , pub reserved : Vec < u8 > , } impl OrderTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (initial_collateral , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (final_output_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (long_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (short_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { initial_collateral , final_output_token , long_token , short_token , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OrderUpdated { pub is_create : bool , pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub order : [u8 ; 32] , pub market_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub params : OrderParamsForEvent , } impl OrderUpdated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (is_create , rest1) = read_bool (data) ? ; data = rest1 ; let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (order , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (params , rest1) = OrderParamsForEvent :: read (data) ? ; data = rest1 ; Ok ((Self { is_create , id , ts , slot , store , order , market_token , owner , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OtherState { pub padding : Vec < u8 > , pub rev : u64 , pub trade_count : u64 , pub long_token_balance : u64 , pub short_token_balance : u64 , pub funding_factor_per_second : i128 , pub reserved : Vec < u8 > , } impl OtherState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (trade_count , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_balance , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_balance , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { padding , rev , trade_count , long_token_balance , short_token_balance , funding_factor_per_second , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct OutputAmounts { pub output_amount : Vec < u8 > , pub secondary_output_amount : Vec < u8 > , } impl OutputAmounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { output_amount , secondary_output_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Pnl { pub pnl : Vec < u8 > , pub uncapped_pnl : Vec < u8 > , } impl Pnl { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { pnl , uncapped_pnl } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Pool { pub is_pure : u8 , pub padding : Vec < u8 > , pub long_token_amount : u128 , pub short_token_amount : u128 , } impl Pool { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (is_pure , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (long_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (short_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { is_pure , padding , long_token_amount , short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub enum PoolKind { Primary , SwapImpact , ClaimableFee , OpenInterestForLong , OpenInterestForShort , OpenInterestInTokensForLong , OpenInterestInTokensForShort , PositionImpact , BorrowingFactor , FundingAmountPerSizeForLong , FundingAmountPerSizeForShort , ClaimableFundingAmountPerSizeForLong , ClaimableFundingAmountPerSizeForShort , CollateralSumForLong , CollateralSumForShort , TotalBorrowing } impl PoolKind { pub fn read (data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (tag , rest) = read_u8 (data) ? ; let val = match tag { 0u8 => Self :: Primary , 1u8 => Self :: SwapImpact , 2u8 => Self :: ClaimableFee , 3u8 => Self :: OpenInterestForLong , 4u8 => Self :: OpenInterestForShort , 5u8 => Self :: OpenInterestInTokensForLong , 6u8 => Self :: OpenInterestInTokensForShort , 7u8 => Self :: PositionImpact , 8u8 => Self :: BorrowingFactor , 9u8 => Self :: FundingAmountPerSizeForLong , 10u8 => Self :: FundingAmountPerSizeForShort , 11u8 => Self :: ClaimableFundingAmountPerSizeForLong , 12u8 => Self :: ClaimableFundingAmountPerSizeForShort , 13u8 => Self :: CollateralSumForLong , 14u8 => Self :: CollateralSumForShort , 15u8 => Self :: TotalBorrowing , _ => anyhow :: bail ! ("unknown enum tag {} for {}" , tag , stringify ! (PoolKind)) , } ; Ok ((val , rest)) } } # [derive (Debug , serde :: Serialize)] pub struct PoolStorage { pub rev : u64 , pub padding : Vec < u8 > , pub pool : Pool , } impl PoolStorage { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (pool , rest1) = Pool :: read (data) ? ; data = rest1 ; Ok ((Self { rev , padding , pool } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Pools { pub primary : PoolStorage , pub swap_impact : PoolStorage , pub claimable_fee : PoolStorage , pub open_interest_for_long : PoolStorage , pub open_interest_for_short : PoolStorage , pub open_interest_in_tokens_for_long : PoolStorage , pub open_interest_in_tokens_for_short : PoolStorage , pub position_impact : PoolStorage , pub borrowing_factor : PoolStorage , pub funding_amount_per_size_for_long : PoolStorage , pub funding_amount_per_size_for_short : PoolStorage , pub claimable_funding_amount_per_size_for_long : PoolStorage , pub claimable_funding_amount_per_size_for_short : PoolStorage , pub collateral_sum_for_long : PoolStorage , pub collateral_sum_for_short : PoolStorage , pub total_borrowing : PoolStorage , pub reserved : Vec < u8 > , } impl Pools { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (primary , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (swap_impact , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (claimable_fee , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (open_interest_for_long , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (open_interest_for_short , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (open_interest_in_tokens_for_long , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (open_interest_in_tokens_for_short , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (position_impact , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (borrowing_factor , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (funding_amount_per_size_for_long , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (funding_amount_per_size_for_short , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (claimable_funding_amount_per_size_for_long , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (claimable_funding_amount_per_size_for_short , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (collateral_sum_for_long , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (collateral_sum_for_short , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (total_borrowing , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { primary , swap_impact , claimable_fee , open_interest_for_long , open_interest_for_short , open_interest_in_tokens_for_long , open_interest_in_tokens_for_short , position_impact , borrowing_factor , funding_amount_per_size_for_long , funding_amount_per_size_for_short , claimable_funding_amount_per_size_for_long , claimable_funding_amount_per_size_for_short , collateral_sum_for_long , collateral_sum_for_short , total_borrowing , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Position { pub version : u8 , pub bump : u8 , pub store : [u8 ; 32] , pub kind : u8 , pub padding_0 : Vec < u8 > , pub owner : [u8 ; 32] , pub market_token : [u8 ; 32] , pub collateral_token : [u8 ; 32] , pub state : PositionState , pub reserved : Vec < u8 > , } impl Position { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (kind , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (collateral_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = PositionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , store , kind , padding_0 , owner , market_token , collateral_token , state , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PositionDecreased { pub rev : u64 , pub market_token : [u8 ; 32] , pub report : DecreasePositionReport , } impl PositionDecreased { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (report , rest1) = DecreasePositionReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , report } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PositionFees { pub paid_order_and_borrowing_fee_value : Vec < u8 > , pub order : OrderFees , pub borrowing : BorrowingFees , pub funding : FundingFees , pub liquidation : Option < LiquidationFees > , } impl PositionFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (order , rest1) = OrderFees :: read (data) ? ; data = rest1 ; let (borrowing , rest1) = BorrowingFees :: read (data) ? ; data = rest1 ; let (funding , rest1) = FundingFees :: read (data) ? ; data = rest1 ; let (tag , r1) = read_u8 (data) ? ; data = r1 ; let liquidation = if tag == 0 { None } else { let (v , r2) = LiquidationFees :: read (data) ? ; data = r2 ; Some (v) } ; Ok ((Self { paid_order_and_borrowing_fee_value , order , borrowing , funding , liquidation } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PositionIncreased { pub rev : u64 , pub market_token : [u8 ; 32] , pub report : IncreasePositionReport , } impl PositionIncreased { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (report , rest1) = IncreasePositionReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , report } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PositionState { pub trade_id : u64 , pub increased_at : i64 , pub updated_at_slot : u64 , pub decreased_at : i64 , pub size_in_tokens : u128 , pub collateral_amount : u128 , pub size_in_usd : u128 , pub borrowing_factor : u128 , pub funding_fee_amount_per_size : u128 , pub long_token_claimable_funding_amount_per_size : u128 , pub short_token_claimable_funding_amount_per_size : u128 , pub reserved : Vec < u8 > , } impl PositionState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (trade_id , rest1) = read_u64 (data) ? ; data = rest1 ; let (increased_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (updated_at_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (decreased_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (size_in_tokens , rest1) = read_u128 (data) ? ; data = rest1 ; let (collateral_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (size_in_usd , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; let (long_token_claimable_funding_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; let (short_token_claimable_funding_amount_per_size , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { trade_id , increased_at , updated_at_slot , decreased_at , size_in_tokens , collateral_amount , size_in_usd , borrowing_factor , funding_fee_amount_per_size , long_token_claimable_funding_amount_per_size , short_token_claimable_funding_amount_per_size , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Price { pub min : Vec < u8 > , pub max : Vec < u8 > , } impl Price { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { min , max } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PriceFeed { pub bump : u8 , pub provider : u8 , pub index : u16 , pub padding_0 : Vec < u8 > , pub store : [u8 ; 32] , pub authority : [u8 ; 32] , pub token : [u8 ; 32] , pub feed_id : [u8 ; 32] , pub last_published_at_slot : u64 , pub last_published_at : i64 , pub price : PriceFeedPrice , pub reserved : Vec < u8 > , } impl PriceFeed { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; let (index , rest1) = read_u16 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (feed_id , rest1) = read_pubkey (data) ? ; data = rest1 ; let (last_published_at_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (last_published_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (price , rest1) = PriceFeedPrice :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { bump , provider , index , padding_0 , store , authority , token , feed_id , last_published_at_slot , last_published_at , price , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PriceFeedPrice { pub decimals : u8 , pub flags : PriceFlagContainer , pub padding : Vec < u8 > , pub last_update_diff : u32 , pub ts : i64 , pub price : u128 , pub min_price : u128 , pub max_price : u128 , } impl PriceFeedPrice { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (decimals , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = PriceFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (last_update_diff , rest1) = read_u32 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (price , rest1) = read_u128 (data) ? ; data = rest1 ; let (min_price , rest1) = read_u128 (data) ? ; data = rest1 ; let (max_price , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { decimals , flags , padding , last_update_diff , ts , price , min_price , max_price } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PriceFlagContainer { pub value : u8 , } impl PriceFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PriceMap { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl PriceMap { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PriceMapEntry { pub key : Vec < u8 > , pub value : SmallPrices , } impl PriceMapEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = SmallPrices :: read (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Prices { pub index_token_price : Price , pub long_token_price : Price , pub short_token_price : Price , } impl Prices { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index_token_price , rest1) = Price :: read (data) ? ; data = rest1 ; let (long_token_price , rest1) = Price :: read (data) ? ; data = rest1 ; let (short_token_price , rest1) = Price :: read (data) ? ; data = rest1 ; Ok ((Self { index_token_price , long_token_price , short_token_price } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Referral { pub referrer : [u8 ; 32] , pub code : [u8 ; 32] , pub referee_count : u128 , pub reserved : Vec < u8 > , } impl Referral { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (referrer , rest1) = read_pubkey (data) ? ; data = rest1 ; let (code , rest1) = read_pubkey (data) ? ; data = rest1 ; let (referee_count , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { referrer , code , referee_count , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ReferralCodeV2 { pub version : u8 , pub bump : u8 , pub code : Vec < u8 > , pub store : [u8 ; 32] , pub owner : [u8 ; 32] , pub next_owner : [u8 ; 32] , pub reserved : Vec < u8 > , } impl ReferralCodeV2 { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (next_owner , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , code , store , owner , next_owner , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RevertibleBuffer { pub rev : u64 , pub padding : Vec < u8 > , pub state : State , } impl RevertibleBuffer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (state , rest1) = State :: read (data) ? ; data = rest1 ; Ok ((Self { rev , padding , state } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RevertiblePoolBuffer { pub rev : u64 , pub padding : Vec < u8 > , pub pool : PoolStorage , } impl RevertiblePoolBuffer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (pool , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; Ok ((Self { rev , padding , pool } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RoleMap { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl RoleMap { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RoleMapEntry { pub key : Vec < u8 > , pub value : RoleMetadata , } impl RoleMapEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = RoleMetadata :: read (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RoleMetadata { pub name : Vec < u8 > , pub enabled : u8 , pub index : u8 , } impl RoleMetadata { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (enabled , rest1) = read_u8 (data) ? ; data = rest1 ; let (index , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { name , enabled , index } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RoleStore { pub roles : RoleMap , pub members : Members , } impl RoleStore { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (roles , rest1) = RoleMap :: read (data) ? ; data = rest1 ; let (members , rest1) = Members :: read (data) ? ; data = rest1 ; Ok ((Self { roles , members } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Shift { pub header : ActionHeader , pub tokens : ShiftTokenAccounts , pub params : ShiftActionParams , pub reserved : Vec < u8 > , } impl Shift { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (tokens , rest1) = ShiftTokenAccounts :: read (data) ? ; data = rest1 ; let (params , rest1) = ShiftActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , tokens , params , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ShiftActionParams { pub from_market_token_amount : u64 , pub min_to_market_token_amount : u64 , pub reserved : Vec < u8 > , } impl ShiftActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (from_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_to_market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { from_market_token_amount , min_to_market_token_amount , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ShiftRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub shift : [u8 ; 32] , pub market_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl ShiftRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (shift , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , shift , market_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ShiftTokenAccounts { pub from_market_token : TokenAndAccount , pub to_market_token : TokenAndAccount , pub long_token : [u8 ; 32] , pub short_token : [u8 ; 32] , pub reserved : Vec < u8 > , } impl ShiftTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (from_market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (to_market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (long_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (short_token , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { from_market_token , to_market_token , long_token , short_token , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SmallPrices { pub decimal_multiplier : u8 , pub flags : u8 , pub padding_0 : Vec < u8 > , pub min : u32 , pub max : u32 , } impl SmallPrices { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (decimal_multiplier , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (min , rest1) = read_u32 (data) ? ; data = rest1 ; let (max , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { decimal_multiplier , flags , padding_0 , min , max } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct State { pub pools : Pools , pub clocks : Clocks , pub other : OtherState , pub reserved : Vec < u8 > , } impl State { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (pools , rest1) = Pools :: read (data) ? ; data = rest1 ; let (clocks , rest1) = Clocks :: read (data) ? ; data = rest1 ; let (other , rest1) = OtherState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { pools , clocks , other , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Store { pub version : u8 , pub bump : Vec < u8 > , pub key_seed : Vec < u8 > , pub key : Vec < u8 > , pub padding_0 : Vec < u8 > , pub role : RoleStore , pub authority : [u8 ; 32] , pub next_authority : [u8 ; 32] , pub token_map : [u8 ; 32] , pub disabled_features : DisabledFeatures , pub padding_1 : Vec < u8 > , pub last_restarted_slot : u64 , pub treasury : Treasury , pub amount : Amounts , pub padding_2 : Vec < u8 > , pub factor : Factors , pub address : Addresses , pub gt : GtState , pub reserved : Vec < u8 > , } impl Store { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (role , rest1) = RoleStore :: read (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (next_authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (token_map , rest1) = read_pubkey (data) ? ; data = rest1 ; let (disabled_features , rest1) = DisabledFeatures :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (last_restarted_slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (treasury , rest1) = Treasury :: read (data) ? ; data = rest1 ; let (amount , rest1) = Amounts :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (factor , rest1) = Factors :: read (data) ? ; data = rest1 ; let (address , rest1) = Addresses :: read (data) ? ; data = rest1 ; let (gt , rest1) = GtState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , key_seed , key , padding_0 , role , authority , next_authority , token_map , disabled_features , padding_1 , last_restarted_slot , treasury , amount , padding_2 , factor , address , gt , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SwapActionParams { pub primary_length : u8 , pub secondary_length : u8 , pub num_tokens : u8 , pub padding_0 : Vec < u8 > , pub current_market_token : [u8 ; 32] , pub paths : Vec < u8 > , pub tokens : Vec < u8 > , } impl SwapActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (primary_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (secondary_length , rest1) = read_u8 (data) ? ; data = rest1 ; let (num_tokens , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (current_market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { primary_length , secondary_length , num_tokens , padding_0 , current_market_token , paths , tokens } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SwapExecuted { pub rev : u64 , pub market_token : [u8 ; 32] , pub report : SwapReport , pub ty : Option < DecreasePositionSwapType > , } impl SwapExecuted { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (report , rest1) = SwapReport :: read (data) ? ; data = rest1 ; let (tag , r1) = read_u8 (data) ? ; data = r1 ; let ty = if tag == 0 { None } else { let (v , r2) = DecreasePositionSwapType :: read (data) ? ; data = r2 ; Some (v) } ; Ok ((Self { rev , market_token , report , ty } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SwapParams { pub is_token_in_long : bool , pub token_in_amount : Vec < u8 > , pub prices : Prices , } impl SwapParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (is_token_in_long , rest1) = read_bool (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; Ok ((Self { is_token_in_long , token_in_amount , prices } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SwapReport { pub params : SwapParams , pub result : SwapResult , } impl SwapReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = SwapParams :: read (data) ? ; data = rest1 ; let (result , rest1) = SwapResult :: read (data) ? ; data = rest1 ; Ok ((Self { params , result } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SwapResult { pub token_in_fees : Fees , pub token_out_amount : Vec < u8 > , pub price_impact_value : Vec < u8 > , pub price_impact_amount : Vec < u8 > , } impl SwapResult { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token_in_fees , rest1) = Fees :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { token_in_fees , token_out_amount , price_impact_value , price_impact_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenAndAccount { pub token : [u8 ; 32] , pub account : [u8 ; 32] , } impl TokenAndAccount { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (account , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token , account } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenMapHeader { pub version : u8 , pub padding_0 : Vec < u8 > , pub store : [u8 ; 32] , pub tokens : Tokens , pub reserved : Vec < u8 > , } impl TokenMapHeader { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (tokens , rest1) = Tokens :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , padding_0 , store , tokens , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Tokens { pub data : Vec < u8 > , pub padding : Vec < u8 > , pub count : u32 , } impl Tokens { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; let (count , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { data , padding , count } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokensEntry { pub key : Vec < u8 > , pub value : u8 , } impl TokensEntry { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradeData { pub flags : u8 , pub padding_0 : Vec < u8 > , pub trade_id : u64 , pub authority : [u8 ; 32] , pub store : [u8 ; 32] , pub market_token : [u8 ; 32] , pub user : [u8 ; 32] , pub position : [u8 ; 32] , pub order : [u8 ; 32] , pub final_output_token : [u8 ; 32] , pub ts : i64 , pub slot : u64 , pub before : PositionState , pub after : PositionState , pub transfer_out : TransferOut , pub padding_1 : Vec < u8 > , pub prices : TradePrices , pub execution_price : u128 , pub price_impact_value : i128 , pub price_impact_diff : u128 , pub pnl : TradePnl , pub fees : TradeFees , pub output_amounts : TradeOutputAmounts , } impl TradeData { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (flags , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (trade_id , rest1) = read_u64 (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (user , rest1) = read_pubkey (data) ? ; data = rest1 ; let (position , rest1) = read_pubkey (data) ? ; data = rest1 ; let (order , rest1) = read_pubkey (data) ? ; data = rest1 ; let (final_output_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (before , rest1) = PositionState :: read (data) ? ; data = rest1 ; let (after , rest1) = PositionState :: read (data) ? ; data = rest1 ; let (transfer_out , rest1) = TransferOut :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = TradePrices :: read (data) ? ; data = rest1 ; let (execution_price , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; let (price_impact_diff , rest1) = read_u128 (data) ? ; data = rest1 ; let (pnl , rest1) = TradePnl :: read (data) ? ; data = rest1 ; let (fees , rest1) = TradeFees :: read (data) ? ; data = rest1 ; let (output_amounts , rest1) = TradeOutputAmounts :: read (data) ? ; data = rest1 ; Ok ((Self { flags , padding_0 , trade_id , authority , store , market_token , user , position , order , final_output_token , ts , slot , before , after , transfer_out , padding_1 , prices , execution_price , price_impact_value , price_impact_diff , pnl , fees , output_amounts } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradeEvent { pub flags : u8 , pub padding_0 : Vec < u8 > , pub trade_id : u64 , pub authority : [u8 ; 32] , pub store : [u8 ; 32] , pub market_token : [u8 ; 32] , pub user : [u8 ; 32] , pub position : [u8 ; 32] , pub order : [u8 ; 32] , pub final_output_token : [u8 ; 32] , pub ts : i64 , pub slot : u64 , pub before : EventPositionState , pub after : EventPositionState , pub transfer_out : EventTransferOut , pub padding_1 : Vec < u8 > , pub prices : EventTradePrices , pub execution_price : u128 , pub price_impact_value : i128 , pub price_impact_diff : u128 , pub pnl : EventTradePnl , pub fees : EventTradeFees , pub output_amounts : EventTradeOutputAmounts , } impl TradeEvent { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (flags , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (trade_id , rest1) = read_u64 (data) ? ; data = rest1 ; let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (user , rest1) = read_pubkey (data) ? ; data = rest1 ; let (position , rest1) = read_pubkey (data) ? ; data = rest1 ; let (order , rest1) = read_pubkey (data) ? ; data = rest1 ; let (final_output_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (before , rest1) = EventPositionState :: read (data) ? ; data = rest1 ; let (after , rest1) = EventPositionState :: read (data) ? ; data = rest1 ; let (transfer_out , rest1) = EventTransferOut :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = EventTradePrices :: read (data) ? ; data = rest1 ; let (execution_price , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; let (price_impact_diff , rest1) = read_u128 (data) ? ; data = rest1 ; let (pnl , rest1) = EventTradePnl :: read (data) ? ; data = rest1 ; let (fees , rest1) = EventTradeFees :: read (data) ? ; data = rest1 ; let (output_amounts , rest1) = EventTradeOutputAmounts :: read (data) ? ; data = rest1 ; Ok ((Self { flags , padding_0 , trade_id , authority , store , market_token , user , position , order , final_output_token , ts , slot , before , after , transfer_out , padding_1 , prices , execution_price , price_impact_value , price_impact_diff , pnl , fees , output_amounts } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradeFees { pub order_fee_for_receiver_amount : u128 , pub order_fee_for_pool_amount : u128 , pub liquidation_fee_amount : u128 , pub liquidation_fee_for_receiver_amount : u128 , pub total_borrowing_fee_amount : u128 , pub borrowing_fee_for_receiver_amount : u128 , pub funding_fee_amount : u128 , pub claimable_funding_fee_long_token_amount : u128 , pub claimable_funding_fee_short_token_amount : u128 , } impl TradeFees { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (order_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (order_fee_for_pool_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (liquidation_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (total_borrowing_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (borrowing_fee_for_receiver_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (funding_fee_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (claimable_funding_fee_long_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (claimable_funding_fee_short_token_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { order_fee_for_receiver_amount , order_fee_for_pool_amount , liquidation_fee_amount , liquidation_fee_for_receiver_amount , total_borrowing_fee_amount , borrowing_fee_for_receiver_amount , funding_fee_amount , claimable_funding_fee_long_token_amount , claimable_funding_fee_short_token_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradeOutputAmounts { pub output_amount : u128 , pub secondary_output_amount : u128 , } impl TradeOutputAmounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (output_amount , rest1) = read_u128 (data) ? ; data = rest1 ; let (secondary_output_amount , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { output_amount , secondary_output_amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradePnl { pub pnl : i128 , pub uncapped_pnl : i128 , } impl TradePnl { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; anyhow :: bail ! ("unsupported type: {}" , "i128") ; ; Ok ((Self { pnl , uncapped_pnl } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradePrice { pub min : u128 , pub max : u128 , } impl TradePrice { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (min , rest1) = read_u128 (data) ? ; data = rest1 ; let (max , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { min , max } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TradePrices { pub index : TradePrice , pub long : TradePrice , pub short : TradePrice , } impl TradePrices { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = TradePrice :: read (data) ? ; data = rest1 ; let (long , rest1) = TradePrice :: read (data) ? ; data = rest1 ; let (short , rest1) = TradePrice :: read (data) ? ; data = rest1 ; Ok ((Self { index , long , short } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TransferOut { pub executed : u8 , pub padding_0 : Vec < u8 > , pub final_output_token : u64 , pub secondary_output_token : u64 , pub long_token : u64 , pub short_token : u64 , pub long_token_for_claimable_account_of_user : u64 , pub short_token_for_claimable_account_of_user : u64 , pub long_token_for_claimable_account_of_holding : u64 , pub short_token_for_claimable_account_of_holding : u64 , } impl TransferOut { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (executed , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (final_output_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (secondary_output_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_for_claimable_account_of_user , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_for_claimable_account_of_user , rest1) = read_u64 (data) ? ; data = rest1 ; let (long_token_for_claimable_account_of_holding , rest1) = read_u64 (data) ? ; data = rest1 ; let (short_token_for_claimable_account_of_holding , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { executed , padding_0 , final_output_token , secondary_output_token , long_token , short_token , long_token_for_claimable_account_of_user , short_token_for_claimable_account_of_user , long_token_for_claimable_account_of_holding , short_token_for_claimable_account_of_holding } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Treasury { pub receiver : [u8 ; 32] , pub next_receiver : [u8 ; 32] , pub reserved : Vec < u8 > , } impl Treasury { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (receiver , rest1) = read_pubkey (data) ? ; data = rest1 ; let (next_receiver , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { receiver , next_receiver , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateBorrowingReport { pub duration_in_seconds : u64 , pub next_cumulative_borrowing_factor_for_long : Vec < u8 > , pub next_cumulative_borrowing_factor_for_short : Vec < u8 > , } impl UpdateBorrowingReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (duration_in_seconds , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { duration_in_seconds , next_cumulative_borrowing_factor_for_long , next_cumulative_borrowing_factor_for_short } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateFundingReport { pub duration_in_seconds : u64 , pub next_funding_factor_per_second : Vec < u8 > , pub delta_funding_amount_per_size : Vec < u8 > , pub delta_claimable_funding_amount_per_size : Vec < u8 > , } impl UpdateFundingReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (duration_in_seconds , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { duration_in_seconds , next_funding_factor_per_second , delta_funding_amount_per_size , delta_claimable_funding_amount_per_size } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateGlvParams { pub min_tokens_for_first_deposit : Option < u64 > , pub shift_min_interval_secs : Option < u32 > , pub shift_max_price_impact_factor : Option < u128 > , pub shift_min_value : Option < u128 > , } impl UpdateGlvParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported option inner") ; ; anyhow :: bail ! ("unsupported option inner") ; ; let (shift_max_price_impact_factor , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (shift_min_value , rest1) = read_option_u128 (data) ? ; data = rest1 ; Ok ((Self { min_tokens_for_first_deposit , shift_min_interval_secs , shift_max_price_impact_factor , shift_min_value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateOrderParams { pub size_delta_value : Option < u128 > , pub acceptable_price : Option < u128 > , pub trigger_price : Option < u128 > , pub min_output : Option < u128 > , pub valid_from_ts : Option < i64 > , } impl UpdateOrderParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (size_delta_value , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (acceptable_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (trigger_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (min_output , rest1) = read_option_u128 (data) ? ; data = rest1 ; let (valid_from_ts , rest1) = read_option_i64 (data) ? ; data = rest1 ; Ok ((Self { size_delta_value , acceptable_price , trigger_price , min_output , valid_from_ts } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateTokenConfigParams { pub heartbeat_duration : u32 , pub precision : u8 , pub feeds : Vec < u8 > , pub timestamp_adjustments : Vec < u8 > , pub expected_provider : Option < u8 > , } impl UpdateTokenConfigParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (heartbeat_duration , rest1) = read_u32 (data) ? ; data = rest1 ; let (precision , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported option inner") ; ; Ok ((Self { heartbeat_duration , precision , feeds , timestamp_adjustments , expected_provider } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UserFlagContainer { pub value : u8 , } impl UserFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UserGtState { pub rank : u8 , pub padding_0 : Vec < u8 > , pub last_minted_at : i64 , pub total_minted : u64 , pub amount : u64 , pub padding_1 : Vec < u8 > , pub paid_fee_value : u128 , pub minted_fee_value : u128 , pub reserved : Vec < u8 > , } impl UserGtState { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rank , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (last_minted_at , rest1) = read_i64 (data) ? ; data = rest1 ; let (total_minted , rest1) = read_u64 (data) ? ; data = rest1 ; let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (paid_fee_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (minted_fee_value , rest1) = read_u128 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { rank , padding_0 , last_minted_at , total_minted , amount , padding_1 , paid_fee_value , minted_fee_value , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UserHeader { pub version : u8 , pub bump : u8 , pub flags : UserFlagContainer , pub padding_0 : Vec < u8 > , pub owner : [u8 ; 32] , pub store : [u8 ; 32] , pub referral : Referral , pub gt : UserGtState , pub reserved : Vec < u8 > , } impl UserHeader { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = UserFlagContainer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (referral , rest1) = Referral :: read (data) ? ; data = rest1 ; let (gt , rest1) = UserGtState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , flags , padding_0 , owner , store , referral , gt , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct VirtualInventory { pub version : u8 , pub bump : u8 , pub flags : VirtualInventoryFlagContainer , pub long_amount_decimals : u8 , pub short_amount_decimals : u8 , pub padding_0 : Vec < u8 > , pub ref_count : u32 , pub index : u32 , pub padding_1 : Vec < u8 > , pub store : [u8 ; 32] , pub pool : PoolStorage , pub buffer : RevertiblePoolBuffer , pub reserved_0 : Vec < u8 > , } impl VirtualInventory { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (version , rest1) = read_u8 (data) ? ; data = rest1 ; let (bump , rest1) = read_u8 (data) ? ; data = rest1 ; let (flags , rest1) = VirtualInventoryFlagContainer :: read (data) ? ; data = rest1 ; let (long_amount_decimals , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_amount_decimals , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (ref_count , rest1) = read_u32 (data) ? ; data = rest1 ; let (index , rest1) = read_u32 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (pool , rest1) = PoolStorage :: read (data) ? ; data = rest1 ; let (buffer , rest1) = RevertiblePoolBuffer :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { version , bump , flags , long_amount_decimals , short_amount_decimals , padding_0 , ref_count , index , padding_1 , store , pool , buffer , reserved_0 } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct VirtualInventoryFlagContainer { pub value : u8 , } impl VirtualInventoryFlagContainer { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (value , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawParams { pub market_token_amount : Vec < u8 > , pub prices : Prices , } impl WithdrawParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; Ok ((Self { market_token_amount , prices } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawReport { pub params : WithdrawParams , pub long_token_fees : Fees , pub short_token_fees : Fees , pub long_token_output : Vec < u8 > , pub short_token_output : Vec < u8 > , } impl WithdrawReport { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = WithdrawParams :: read (data) ? ; data = rest1 ; let (long_token_fees , rest1) = Fees :: read (data) ? ; data = rest1 ; let (short_token_fees , rest1) = Fees :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { params , long_token_fees , short_token_fees , long_token_output , short_token_output } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct Withdrawal { pub header : ActionHeader , pub tokens : WithdrawalTokenAccounts , pub params : WithdrawalActionParams , pub swap : SwapActionParams , pub padding_1 : Vec < u8 > , pub reserved : Vec < u8 > , } impl Withdrawal { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (header , rest1) = ActionHeader :: read (data) ? ; data = rest1 ; let (tokens , rest1) = WithdrawalTokenAccounts :: read (data) ? ; data = rest1 ; let (params , rest1) = WithdrawalActionParams :: read (data) ? ; data = rest1 ; let (swap , rest1) = SwapActionParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { header , tokens , params , swap , padding_1 , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawalActionParams { pub market_token_amount : u64 , pub min_long_token_amount : u64 , pub min_short_token_amount : u64 , pub reserved : Vec < u8 > , } impl WithdrawalActionParams { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (market_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_long_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; let (min_short_token_amount , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { market_token_amount , min_long_token_amount , min_short_token_amount , reserved } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawalCreated { pub ts : i64 , pub store : [u8 ; 32] , pub withdrawal : [u8 ; 32] , } impl WithdrawalCreated { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (withdrawal , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { ts , store , withdrawal } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawalExecuted { pub rev : u64 , pub market_token : [u8 ; 32] , pub report : WithdrawReport , } impl WithdrawalExecuted { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (rev , rest1) = read_u64 (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (report , rest1) = WithdrawReport :: read (data) ? ; data = rest1 ; Ok ((Self { rev , market_token , report } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawalRemoved { pub id : u64 , pub ts : i64 , pub slot : u64 , pub store : [u8 ; 32] , pub withdrawal : [u8 ; 32] , pub market_token : [u8 ; 32] , pub owner : [u8 ; 32] , pub state : ActionState , pub reason : String , } impl WithdrawalRemoved { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (id , rest1) = read_u64 (data) ? ; data = rest1 ; let (ts , rest1) = read_i64 (data) ? ; data = rest1 ; let (slot , rest1) = read_u64 (data) ? ; data = rest1 ; let (store , rest1) = read_pubkey (data) ? ; data = rest1 ; let (withdrawal , rest1) = read_pubkey (data) ? ; data = rest1 ; let (market_token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (owner , rest1) = read_pubkey (data) ? ; data = rest1 ; let (state , rest1) = ActionState :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { id , ts , slot , store , withdrawal , market_token , owner , state , reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct WithdrawalTokenAccounts { pub final_long_token : TokenAndAccount , pub final_short_token : TokenAndAccount , pub market_token : TokenAndAccount , pub reserved : Vec < u8 > , } impl WithdrawalTokenAccounts { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (final_long_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (final_short_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; let (market_token , rest1) = TokenAndAccount :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { final_long_token , final_short_token , market_token , reserved } , data)) } } } pub mod accounts_data { use serde :: Serialize ; # [derive (Debug , serde :: Serialize)] pub struct AcceptReceiverAccounts { pub next_receiver : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct AcceptReferralCodeAccounts { pub next_owner : String , pub store : String , pub user : String , pub referral_code : String , pub receiver_user : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct AcceptStoreAuthorityAccounts { pub next_authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct AutoDeleverageAccounts { pub authority : String , pub owner : String , pub user : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub order : String , pub position : String , pub event : String , pub long_token : String , pub short_token : String , pub long_token_escrow : String , pub short_token_escrow : String , pub long_token_vault : String , pub short_token_vault : String , pub claimable_long_token_account_for_user : String , pub claimable_short_token_account_for_user : String , pub claimable_pnl_token_account_for_holding : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CancelOrderIfNoPositionAccounts { pub authority : String , pub store : String , pub order : String , pub position : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CancelReferralCodeTransferAccounts { pub owner : String , pub store : String , pub user : String , pub referral_code : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CheckAdminAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CheckRoleAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ClaimFeesFromMarketAccounts { pub authority : String , pub store : String , pub market : String , pub token_mint : String , pub vault : String , pub target : String , pub token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ClearAllPricesAccounts { pub authority : String , pub store : String , pub oracle : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseDepositAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub deposit : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub market_token_ata : String , pub initial_long_token_ata : String , pub initial_short_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseEmptyClaimableAccountAccounts { pub authority : String , pub store : String , pub mint : String , pub owner : String , pub account : String , pub system_program : String , pub token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvDepositAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub glv_deposit : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub glv_token : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub glv_token_escrow : String , pub market_token_ata : String , pub initial_long_token_ata : String , pub initial_short_token_ata : String , pub glv_token_ata : String , pub system_program : String , pub token_program : String , pub glv_token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvShiftAccounts { pub authority : String , pub funder : String , pub store : String , pub store_wallet : String , pub glv : String , pub glv_shift : String , pub from_market_token : String , pub to_market_token : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvWithdrawalAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub glv_withdrawal : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub glv_token : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub market_token_ata : String , pub final_long_token_ata : String , pub final_short_token_ata : String , pub glv_token_escrow : String , pub glv_token_ata : String , pub system_program : String , pub token_program : String , pub glv_token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseGtExchangeAccounts { pub authority : String , pub store : String , pub owner : String , pub vault : String , pub exchange : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseMarketConfigBufferAccounts { pub authority : String , pub buffer : String , pub receiver : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseOrderAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub rent_receiver : String , pub user : String , pub referrer_user : String , pub order : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_ata : String , pub final_output_token_ata : String , pub long_token_ata : String , pub short_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseOrderV2Accounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub rent_receiver : String , pub user : String , pub referrer_user : String , pub order : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_ata : String , pub final_output_token_ata : String , pub long_token_ata : String , pub short_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub callback_authority : String , pub callback_program : String , pub callback_shared_data_account : String , pub callback_partitioned_data_account : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseShiftAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub shift : String , pub from_market_token : String , pub to_market_token : String , pub from_market_token_escrow : String , pub to_market_token_escrow : String , pub from_market_token_ata : String , pub to_market_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseVirtualInventoryAccounts { pub authority : String , pub store : String , pub store_wallet : String , pub virtual_inventory : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CloseWithdrawalAccounts { pub executor : String , pub store : String , pub store_wallet : String , pub owner : String , pub receiver : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub withdrawal : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub market_token_ata : String , pub final_long_token_ata : String , pub final_short_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ConfirmGtExchangeVaultAccounts { pub authority : String , pub store : String , pub vault : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ConfirmGtExchangeVaultV2Accounts { pub authority : String , pub store : String , pub vault : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateDepositAccounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub deposit : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub market_token_ata : String , pub initial_long_token_source : String , pub initial_short_token_source : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvDepositAccounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub glv : String , pub glv_deposit : String , pub glv_token : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub market_token_source : String , pub initial_long_token_source : String , pub initial_short_token_source : String , pub glv_token_escrow : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub system_program : String , pub token_program : String , pub glv_token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvShiftAccounts { pub authority : String , pub store : String , pub glv : String , pub from_market : String , pub to_market : String , pub glv_shift : String , pub from_market_token : String , pub to_market_token : String , pub from_market_token_vault : String , pub to_market_token_vault : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvWithdrawalAccounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub glv : String , pub glv_withdrawal : String , pub glv_token : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub glv_token_source : String , pub glv_token_escrow : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub system_program : String , pub token_program : String , pub glv_token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateOrderAccounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub user : String , pub order : String , pub position : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_source : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateOrderV2Accounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub user : String , pub order : String , pub position : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_source : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub callback_authority : String , pub callback_program : String , pub callback_shared_data_account : String , pub callback_partitioned_data_account : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateShiftAccounts { pub owner : String , pub receiver : String , pub store : String , pub from_market : String , pub to_market : String , pub shift : String , pub from_market_token : String , pub to_market_token : String , pub from_market_token_escrow : String , pub to_market_token_escrow : String , pub from_market_token_source : String , pub to_market_token_ata : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateTokenMetadataAccounts { pub authority : String , pub store : String , pub mint : String , pub metadata : String , pub system_program : String , pub sysvar_instructions : String , pub metadata_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateVirtualInventoryForPositionsAccounts { pub authority : String , pub store : String , pub index_token : String , pub virtual_inventory : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateVirtualInventoryForSwapsAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct CreateWithdrawalAccounts { pub owner : String , pub receiver : String , pub store : String , pub market : String , pub withdrawal : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub market_token_source : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct DisableRoleAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct DisableVirtualInventoryAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct EnableRoleAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDecreaseOrderAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub owner : String , pub user : String , pub order : String , pub position : String , pub event : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub final_output_token_vault : String , pub long_token_vault : String , pub short_token_vault : String , pub claimable_long_token_account_for_user : String , pub claimable_short_token_account_for_user : String , pub claimable_pnl_token_account_for_holding : String , pub token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDecreaseOrderV2Accounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub owner : String , pub user : String , pub order : String , pub position : String , pub event : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub final_output_token_vault : String , pub long_token_vault : String , pub short_token_vault : String , pub claimable_long_token_account_for_user : String , pub claimable_short_token_account_for_user : String , pub claimable_pnl_token_account_for_holding : String , pub token_program : String , pub system_program : String , pub callback_authority : String , pub callback_program : String , pub callback_shared_data_account : String , pub callback_partitioned_data_account : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDepositAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub deposit : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub initial_long_token_vault : String , pub initial_short_token_vault : String , pub token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvDepositAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub glv : String , pub market : String , pub glv_deposit : String , pub glv_token : String , pub market_token : String , pub initial_long_token : String , pub initial_short_token : String , pub glv_token_escrow : String , pub market_token_escrow : String , pub initial_long_token_escrow : String , pub initial_short_token_escrow : String , pub initial_long_token_vault : String , pub initial_short_token_vault : String , pub market_token_vault : String , pub token_program : String , pub glv_token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvShiftAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub glv : String , pub from_market : String , pub to_market : String , pub glv_shift : String , pub from_market_token : String , pub to_market_token : String , pub from_market_token_glv_vault : String , pub to_market_token_glv_vault : String , pub from_market_token_vault : String , pub token_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvWithdrawalAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub glv : String , pub market : String , pub glv_withdrawal : String , pub glv_token : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub glv_token_escrow : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub market_token_withdrawal_vault : String , pub final_long_token_vault : String , pub final_short_token_vault : String , pub market_token_vault : String , pub token_program : String , pub glv_token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteIncreaseOrSwapOrderAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub owner : String , pub user : String , pub order : String , pub position : String , pub event : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_vault : String , pub final_output_token_vault : String , pub long_token_vault : String , pub short_token_vault : String , pub token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteIncreaseOrSwapOrderV2Accounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub owner : String , pub user : String , pub order : String , pub position : String , pub event : String , pub initial_collateral_token : String , pub final_output_token : String , pub long_token : String , pub short_token : String , pub initial_collateral_token_escrow : String , pub final_output_token_escrow : String , pub long_token_escrow : String , pub short_token_escrow : String , pub initial_collateral_token_vault : String , pub final_output_token_vault : String , pub long_token_vault : String , pub short_token_vault : String , pub token_program : String , pub system_program : String , pub callback_authority : String , pub callback_program : String , pub callback_shared_data_account : String , pub callback_partitioned_data_account : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteShiftAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub from_market : String , pub to_market : String , pub shift : String , pub from_market_token : String , pub to_market_token : String , pub from_market_token_escrow : String , pub to_market_token_escrow : String , pub from_market_token_vault : String , pub token_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ExecuteWithdrawalAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub withdrawal : String , pub market_token : String , pub final_long_token : String , pub final_short_token : String , pub market_token_escrow : String , pub final_long_token_escrow : String , pub final_short_token_escrow : String , pub market_token_vault : String , pub final_long_token_vault : String , pub final_short_token_vault : String , pub token_program : String , pub system_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GetMarketStatusAccounts { pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GetMarketTokenPriceAccounts { pub market : String , pub market_token : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GrantRoleAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GtSetExchangeTimeWindowAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GtSetOrderFeeDiscountFactorsAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct GtSetReferralRewardFactorsAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct HasAdminAccounts { pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct HasRoleAccounts { pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeAccounts { pub payer : String , pub authority : String , pub receiver : String , pub holding : String , pub store : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeCallbackAuthorityAccounts { pub payer : String , pub callback_authority : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeGlvAccounts { pub authority : String , pub store : String , pub glv_token : String , pub glv : String , pub system_program : String , pub token_program : String , pub market_token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeGtAccounts { pub authority : String , pub store : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketAccounts { pub authority : String , pub store : String , pub market_token_mint : String , pub long_token_mint : String , pub short_token_mint : String , pub market : String , pub token_map : String , pub long_token_vault : String , pub short_token_vault : String , pub system_program : String , pub token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketConfigBufferAccounts { pub authority : String , pub store : String , pub buffer : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketVaultAccounts { pub authority : String , pub store : String , pub mint : String , pub vault : String , pub system_program : String , pub token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeOracleAccounts { pub payer : String , pub authority : String , pub store : String , pub oracle : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializePriceFeedAccounts { pub authority : String , pub store : String , pub price_feed : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeReferralCodeAccounts { pub owner : String , pub store : String , pub referral_code : String , pub user : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InitializeTokenMapAccounts { pub payer : String , pub store : String , pub token_map : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InsertAddressAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InsertAmountAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InsertFactorAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InsertGlvMarketAccounts { pub authority : String , pub store : String , pub glv : String , pub market_token : String , pub market : String , pub vault : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct InsertOrderFeeDiscountForReferredUserAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct IsTokenConfigEnabledAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct JoinVirtualInventoryForPositionsAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct JoinVirtualInventoryForSwapsAccounts { pub authority : String , pub store : String , pub token_map : String , pub virtual_inventory : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct LeaveDisabledVirtualInventoryAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct LeaveVirtualInventoryForPositionsAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct LeaveVirtualInventoryForSwapsAccounts { pub authority : String , pub store : String , pub virtual_inventory : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct LiquidateAccounts { pub authority : String , pub owner : String , pub user : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub order : String , pub position : String , pub event : String , pub long_token : String , pub short_token : String , pub long_token_escrow : String , pub short_token_escrow : String , pub long_token_vault : String , pub short_token_vault : String , pub claimable_long_token_account_for_user : String , pub claimable_short_token_account_for_user : String , pub claimable_pnl_token_account_for_holding : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub chainlink_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct MarketTransferInAccounts { pub authority : String , pub store : String , pub from_authority : String , pub market : String , pub from : String , pub vault : String , pub token_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct MigrateReferralCodeAccounts { pub authority : String , pub store : String , pub system : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PrepareAssociatedTokenAccountAccounts { pub payer : String , pub owner : String , pub mint : String , pub account : String , pub system_program : String , pub token_program : String , pub associated_token_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PrepareGtExchangeVaultAccounts { pub payer : String , pub store : String , pub vault : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PreparePositionAccounts { pub owner : String , pub store : String , pub market : String , pub position : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PrepareTradeEventBufferAccounts { pub authority : String , pub store : String , pub event : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PrepareUserAccounts { pub owner : String , pub store : String , pub user : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PushToMarketConfigBufferAccounts { pub authority : String , pub buffer : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PushToTokenMapAccounts { pub authority : String , pub store : String , pub token_map : String , pub token : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct PushToTokenMapSyntheticAccounts { pub authority : String , pub store : String , pub token_map : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct RemoveGlvMarketAccounts { pub authority : String , pub store : String , pub store_wallet : String , pub glv : String , pub market_token : String , pub vault : String , pub store_wallet_ata : String , pub token_program : String , pub associated_token_program : String , pub system_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct RequestGtExchangeAccounts { pub owner : String , pub store : String , pub user : String , pub vault : String , pub exchange : String , pub system_program : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct RevokeRoleAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetExpectedProviderAccounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetFeedConfigAccounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetFeedConfigV2Accounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetMarketConfigBufferAuthorityAccounts { pub authority : String , pub buffer : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetPricesFromPriceFeedAccounts { pub authority : String , pub store : String , pub oracle : String , pub token_map : String , pub chainlink_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetReferrerAccounts { pub owner : String , pub store : String , pub user : String , pub referral_code : String , pub referrer_user : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct SetTokenMapAccounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleFeatureAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleGlvMarketFlagAccounts { pub authority : String , pub store : String , pub glv : String , pub market_token : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleGtMintingAccounts { pub authority : String , pub store : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleMarketAccounts { pub authority : String , pub store : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleTokenConfigAccounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct ToggleTokenPriceAdjustmentAccounts { pub authority : String , pub store : String , pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenDecimalsAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenExpectedProviderAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenFeedAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenNameAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenPrecisionAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TokenTimestampAdjustmentAccounts { pub token_map : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TransferReceiverAccounts { pub authority : String , pub store : String , pub next_receiver : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TransferReferralCodeAccounts { pub owner : String , pub store : String , pub user : String , pub referral_code : String , pub receiver_user : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct TransferStoreAuthorityAccounts { pub authority : String , pub store : String , pub next_authority : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateAdlStateAccounts { pub authority : String , pub store : String , pub token_map : String , pub oracle : String , pub market : String , pub chainlink_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateGlvConfigAccounts { pub authority : String , pub store : String , pub glv : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateGlvMarketConfigAccounts { pub authority : String , pub store : String , pub glv : String , pub market_token : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateLastRestartedSlotAccounts { pub authority : String , pub store : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigAccounts { pub authority : String , pub store : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigFlagAccounts { pub authority : String , pub store : String , pub market : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigWithBufferAccounts { pub authority : String , pub store : String , pub market : String , pub buffer : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateOrderAccounts { pub owner : String , pub store : String , pub market : String , pub order : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateOrderV2Accounts { pub owner : String , pub store : String , pub market : String , pub order : String , pub callback_authority : String , pub callback_program : String , pub callback_shared_data_account : String , pub callback_partitioned_data_account : String , pub event_authority : String , pub program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdatePriceFeedWithChainlinkAccounts { pub authority : String , pub store : String , pub verifier_account : String , pub access_controller : String , pub config_account : String , pub price_feed : String , pub chainlink : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UpdateTokenMetadataAccounts { pub authority : String , pub store : String , pub metadata : String , pub metadata_program : String , pub remaining : Vec < String > , } # [derive (Debug , serde :: Serialize)] pub struct UseClaimableAccountAccounts { pub authority : String , pub store : String , pub mint : String , pub owner : String , pub account : String , pub system_program : String , pub token_program : String , pub remaining : Vec < String > , } } pub mod ix_data { use super :: * ; use serde :: Serialize ; # [derive (Debug , serde :: Serialize)] pub struct AcceptReceiverArguments { } impl AcceptReceiverArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct AcceptReferralCodeArguments { } impl AcceptReferralCodeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct AcceptStoreAuthorityArguments { } impl AcceptStoreAuthorityArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct AutoDeleverageArguments { pub nonce : Vec < u8 > , pub recent_timestamp : i64 , pub size_delta_in_usd : u128 , pub execution_fee : u64 , } impl AutoDeleverageArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (size_delta_in_usd , rest1) = read_u128 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { nonce , recent_timestamp , size_delta_in_usd , execution_fee } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CancelOrderIfNoPositionArguments { } impl CancelOrderIfNoPositionArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CancelReferralCodeTransferArguments { } impl CancelReferralCodeTransferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CheckAdminArguments { } impl CheckAdminArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CheckRoleArguments { pub role : String , } impl CheckRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ClaimFeesFromMarketArguments { } impl ClaimFeesFromMarketArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ClearAllPricesArguments { } impl ClearAllPricesArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseDepositArguments { pub reason : String , } impl CloseDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseEmptyClaimableAccountArguments { pub timestamp : i64 , } impl CloseEmptyClaimableAccountArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; Ok ((Self { timestamp } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvDepositArguments { pub reason : String , } impl CloseGlvDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvShiftArguments { pub reason : String , } impl CloseGlvShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseGlvWithdrawalArguments { pub reason : String , } impl CloseGlvWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseGtExchangeArguments { } impl CloseGtExchangeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseMarketConfigBufferArguments { } impl CloseMarketConfigBufferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseOrderArguments { pub reason : String , } impl CloseOrderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseOrderV2Arguments { pub reason : String , } impl CloseOrderV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseShiftArguments { pub reason : String , } impl CloseShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseVirtualInventoryArguments { } impl CloseVirtualInventoryArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CloseWithdrawalArguments { pub reason : String , } impl CloseWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { reason } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ConfirmGtExchangeVaultArguments { } impl ConfirmGtExchangeVaultArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ConfirmGtExchangeVaultV2Arguments { pub buyback_value : u128 , pub buyback_price : Option < u128 > , } impl ConfirmGtExchangeVaultV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (buyback_value , rest1) = read_u128 (data) ? ; data = rest1 ; let (buyback_price , rest1) = read_option_u128 (data) ? ; data = rest1 ; Ok ((Self { buyback_value , buyback_price } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateDepositArguments { pub nonce : Vec < u8 > , pub params : CreateDepositParams , } impl CreateDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateDepositParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvDepositArguments { pub nonce : Vec < u8 > , pub params : CreateGlvDepositParams , } impl CreateGlvDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateGlvDepositParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvShiftArguments { pub nonce : Vec < u8 > , pub params : CreateShiftParams , } impl CreateGlvShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateShiftParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateGlvWithdrawalArguments { pub nonce : Vec < u8 > , pub params : CreateGlvWithdrawalParams , } impl CreateGlvWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateGlvWithdrawalParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateOrderArguments { pub nonce : Vec < u8 > , pub params : CreateOrderParams , } impl CreateOrderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateOrderParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateOrderV2Arguments { pub nonce : Vec < u8 > , pub params : CreateOrderParams , pub callback_version : Option < u8 > , } impl CreateOrderV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateOrderParams :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; Ok ((Self { nonce , params , callback_version } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateShiftArguments { pub nonce : Vec < u8 > , pub params : CreateShiftParams , } impl CreateShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateShiftParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateTokenMetadataArguments { pub name : String , pub symbol : String , pub uri : String , } impl CreateTokenMetadataArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { name , symbol , uri } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateVirtualInventoryForPositionsArguments { } impl CreateVirtualInventoryForPositionsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateVirtualInventoryForSwapsArguments { pub index : u32 , pub long_amount_decimals : u8 , pub short_amount_decimals : u8 , } impl CreateVirtualInventoryForSwapsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = read_u32 (data) ? ; data = rest1 ; let (long_amount_decimals , rest1) = read_u8 (data) ? ; data = rest1 ; let (short_amount_decimals , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { index , long_amount_decimals , short_amount_decimals } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct CreateWithdrawalArguments { pub nonce : Vec < u8 > , pub params : CreateWithdrawalParams , } impl CreateWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (params , rest1) = CreateWithdrawalParams :: read (data) ? ; data = rest1 ; Ok ((Self { nonce , params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DisableRoleArguments { pub role : String , } impl DisableRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct DisableVirtualInventoryArguments { } impl DisableVirtualInventoryArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct EnableRoleArguments { pub role : String , } impl EnableRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDecreaseOrderArguments { pub recent_timestamp : i64 , pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteDecreaseOrderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { recent_timestamp , execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDecreaseOrderV2Arguments { pub recent_timestamp : i64 , pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteDecreaseOrderV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { recent_timestamp , execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteDepositArguments { pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvDepositArguments { pub execution_lamports : u64 , pub throw_on_execution_error : bool , } impl ExecuteGlvDepositArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvShiftArguments { pub execution_lamports : u64 , pub throw_on_execution_error : bool , } impl ExecuteGlvShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteGlvWithdrawalArguments { pub execution_lamports : u64 , pub throw_on_execution_error : bool , } impl ExecuteGlvWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteIncreaseOrSwapOrderArguments { pub recent_timestamp : i64 , pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteIncreaseOrSwapOrderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { recent_timestamp , execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteIncreaseOrSwapOrderV2Arguments { pub recent_timestamp : i64 , pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteIncreaseOrSwapOrderV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { recent_timestamp , execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteShiftArguments { pub execution_lamports : u64 , pub throw_on_execution_error : bool , } impl ExecuteShiftArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_lamports , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_lamports , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ExecuteWithdrawalArguments { pub execution_fee : u64 , pub throw_on_execution_error : bool , } impl ExecuteWithdrawalArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; let (throw_on_execution_error , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { execution_fee , throw_on_execution_error } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GetMarketStatusArguments { pub prices : Prices , pub maximize_pnl : bool , pub maximize_pool_value : bool , } impl GetMarketStatusArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; let (maximize_pnl , rest1) = read_bool (data) ? ; data = rest1 ; let (maximize_pool_value , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { prices , maximize_pnl , maximize_pool_value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GetMarketTokenPriceArguments { pub prices : Prices , pub pnl_factor : String , pub maximize : bool , } impl GetMarketTokenPriceArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (prices , rest1) = Prices :: read (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (maximize , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { prices , pnl_factor , maximize } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GrantRoleArguments { pub user : [u8 ; 32] , pub role : String , } impl GrantRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (user , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { user , role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtSetExchangeTimeWindowArguments { pub window : u32 , } impl GtSetExchangeTimeWindowArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (window , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { window } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtSetOrderFeeDiscountFactorsArguments { pub factors : Vec < u8 > , } impl GtSetOrderFeeDiscountFactorsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { factors } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct GtSetReferralRewardFactorsArguments { pub factors : Vec < u8 > , } impl GtSetReferralRewardFactorsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { factors } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct HasAdminArguments { pub authority : [u8 ; 32] , } impl HasAdminArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { authority } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct HasRoleArguments { pub authority : [u8 ; 32] , pub role : String , } impl HasRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (authority , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { authority , role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeArguments { pub key : String , } impl InitializeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { key } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeCallbackAuthorityArguments { } impl InitializeCallbackAuthorityArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeGlvArguments { pub index : u16 , pub length : u16 , } impl InitializeGlvArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = read_u16 (data) ? ; data = rest1 ; let (length , rest1) = read_u16 (data) ? ; data = rest1 ; Ok ((Self { index , length } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeGtArguments { pub decimals : u8 , pub initial_minting_cost : u128 , pub grow_factor : u128 , pub grow_step : u64 , pub ranks : Vec < u8 > , } impl InitializeGtArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (decimals , rest1) = read_u8 (data) ? ; data = rest1 ; let (initial_minting_cost , rest1) = read_u128 (data) ? ; data = rest1 ; let (grow_factor , rest1) = read_u128 (data) ? ; data = rest1 ; let (grow_step , rest1) = read_u64 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { decimals , initial_minting_cost , grow_factor , grow_step , ranks } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketArguments { pub index_token_mint : [u8 ; 32] , pub name : String , pub enable : bool , } impl InitializeMarketArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index_token_mint , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { index_token_mint , name , enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketConfigBufferArguments { pub expire_after_secs : u32 , } impl InitializeMarketConfigBufferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (expire_after_secs , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { expire_after_secs } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeMarketVaultArguments { } impl InitializeMarketVaultArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeOracleArguments { } impl InitializeOracleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializePriceFeedArguments { pub index : u16 , pub provider : u8 , pub token : [u8 ; 32] , pub feed_id : [u8 ; 32] , } impl InitializePriceFeedArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = read_u16 (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (feed_id , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { index , provider , token , feed_id } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeReferralCodeArguments { pub code : Vec < u8 > , } impl InitializeReferralCodeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { code } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InitializeTokenMapArguments { } impl InitializeTokenMapArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InsertAddressArguments { pub key : String , pub address : [u8 ; 32] , } impl InsertAddressArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (address , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { key , address } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InsertAmountArguments { pub key : String , pub amount : u64 , } impl InsertAmountArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { key , amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InsertFactorArguments { pub key : String , pub factor : u128 , } impl InsertFactorArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (factor , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { key , factor } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InsertGlvMarketArguments { } impl InsertGlvMarketArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct InsertOrderFeeDiscountForReferredUserArguments { pub factor : u128 , } impl InsertOrderFeeDiscountForReferredUserArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (factor , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { factor } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct IsTokenConfigEnabledArguments { pub token : [u8 ; 32] , } impl IsTokenConfigEnabledArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct JoinVirtualInventoryForPositionsArguments { } impl JoinVirtualInventoryForPositionsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct JoinVirtualInventoryForSwapsArguments { } impl JoinVirtualInventoryForSwapsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct LeaveDisabledVirtualInventoryArguments { } impl LeaveDisabledVirtualInventoryArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct LeaveVirtualInventoryForPositionsArguments { } impl LeaveVirtualInventoryForPositionsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct LeaveVirtualInventoryForSwapsArguments { } impl LeaveVirtualInventoryForSwapsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct LiquidateArguments { pub nonce : Vec < u8 > , pub recent_timestamp : i64 , pub execution_fee : u64 , } impl LiquidateArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; let (recent_timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (execution_fee , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { nonce , recent_timestamp , execution_fee } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MarketTransferInArguments { pub amount : u64 , } impl MarketTransferInArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct MigrateReferralCodeArguments { } impl MigrateReferralCodeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PrepareAssociatedTokenAccountArguments { } impl PrepareAssociatedTokenAccountArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PrepareGtExchangeVaultArguments { pub time_window_index : i64 , } impl PrepareGtExchangeVaultArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (time_window_index , rest1) = read_i64 (data) ? ; data = rest1 ; Ok ((Self { time_window_index } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PreparePositionArguments { pub params : CreateOrderParams , } impl PreparePositionArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = CreateOrderParams :: read (data) ? ; data = rest1 ; Ok ((Self { params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PrepareTradeEventBufferArguments { pub index : u16 , } impl PrepareTradeEventBufferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (index , rest1) = read_u16 (data) ? ; data = rest1 ; Ok ((Self { index } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PrepareUserArguments { } impl PrepareUserArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PushToMarketConfigBufferArguments { pub new_configs : Vec < u8 > , } impl PushToMarketConfigBufferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { new_configs } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PushToTokenMapArguments { pub name : String , pub builder : UpdateTokenConfigParams , pub enable : bool , pub new : bool , } impl PushToTokenMapArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (builder , rest1) = UpdateTokenConfigParams :: read (data) ? ; data = rest1 ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; let (new , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { name , builder , enable , new } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct PushToTokenMapSyntheticArguments { pub name : String , pub token : [u8 ; 32] , pub token_decimals : u8 , pub builder : UpdateTokenConfigParams , pub enable : bool , pub new : bool , } impl PushToTokenMapSyntheticArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (token_decimals , rest1) = read_u8 (data) ? ; data = rest1 ; let (builder , rest1) = UpdateTokenConfigParams :: read (data) ? ; data = rest1 ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; let (new , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { name , token , token_decimals , builder , enable , new } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RemoveGlvMarketArguments { } impl RemoveGlvMarketArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RequestGtExchangeArguments { pub amount : u64 , } impl RequestGtExchangeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { amount } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct RevokeRoleArguments { pub user : [u8 ; 32] , pub role : String , } impl RevokeRoleArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (user , rest1) = read_pubkey (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { user , role } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetExpectedProviderArguments { pub token : [u8 ; 32] , pub provider : u8 , } impl SetExpectedProviderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { token , provider } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetFeedConfigArguments { pub token : [u8 ; 32] , pub provider : u8 , pub feed : [u8 ; 32] , pub timestamp_adjustment : u32 , } impl SetFeedConfigArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; let (feed , rest1) = read_pubkey (data) ? ; data = rest1 ; let (timestamp_adjustment , rest1) = read_u32 (data) ? ; data = rest1 ; Ok ((Self { token , provider , feed , timestamp_adjustment } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetFeedConfigV2Arguments { pub token : [u8 ; 32] , pub provider : u8 , pub feed : Option < [u8 ; 32] > , pub timestamp_adjustment : Option < u32 > , pub max_deviation_factor : Option < u128 > , } impl SetFeedConfigV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; anyhow :: bail ! ("unsupported option inner") ; ; anyhow :: bail ! ("unsupported option inner") ; ; let (max_deviation_factor , rest1) = read_option_u128 (data) ? ; data = rest1 ; Ok ((Self { token , provider , feed , timestamp_adjustment , max_deviation_factor } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetMarketConfigBufferAuthorityArguments { pub new_authority : [u8 ; 32] , } impl SetMarketConfigBufferAuthorityArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (new_authority , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { new_authority } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetPricesFromPriceFeedArguments { pub tokens : Vec < u8 > , } impl SetPricesFromPriceFeedArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { tokens } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetReferrerArguments { pub code : Vec < u8 > , } impl SetReferrerArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported field type") ; ; Ok ((Self { code } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct SetTokenMapArguments { } impl SetTokenMapArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleFeatureArguments { pub domain : String , pub action : String , pub enable : bool , } impl ToggleFeatureArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { domain , action , enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleGlvMarketFlagArguments { pub flag : String , pub enable : bool , } impl ToggleGlvMarketFlagArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { flag , enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleGtMintingArguments { pub enable : bool , } impl ToggleGtMintingArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleMarketArguments { pub enable : bool , } impl ToggleMarketArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleTokenConfigArguments { pub token : [u8 ; 32] , pub enable : bool , } impl ToggleTokenConfigArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { token , enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct ToggleTokenPriceAdjustmentArguments { pub token : [u8 ; 32] , pub enable : bool , } impl ToggleTokenPriceAdjustmentArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (enable , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { token , enable } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenDecimalsArguments { pub token : [u8 ; 32] , } impl TokenDecimalsArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenExpectedProviderArguments { pub token : [u8 ; 32] , } impl TokenExpectedProviderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenFeedArguments { pub token : [u8 ; 32] , pub provider : u8 , } impl TokenFeedArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { token , provider } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenNameArguments { pub token : [u8 ; 32] , } impl TokenNameArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenPrecisionArguments { pub token : [u8 ; 32] , } impl TokenPrecisionArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; Ok ((Self { token } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TokenTimestampAdjustmentArguments { pub token : [u8 ; 32] , pub provider : u8 , } impl TokenTimestampAdjustmentArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (token , rest1) = read_pubkey (data) ? ; data = rest1 ; let (provider , rest1) = read_u8 (data) ? ; data = rest1 ; Ok ((Self { token , provider } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TransferReceiverArguments { } impl TransferReceiverArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TransferReferralCodeArguments { } impl TransferReferralCodeArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct TransferStoreAuthorityArguments { } impl TransferStoreAuthorityArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateAdlStateArguments { pub is_long : bool , } impl UpdateAdlStateArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (is_long , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { is_long } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateGlvConfigArguments { pub params : UpdateGlvParams , } impl UpdateGlvConfigArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = UpdateGlvParams :: read (data) ? ; data = rest1 ; Ok ((Self { params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateGlvMarketConfigArguments { pub max_amount : Option < u64 > , pub max_value : Option < u128 > , } impl UpdateGlvMarketConfigArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported option inner") ; ; let (max_value , rest1) = read_option_u128 (data) ? ; data = rest1 ; Ok ((Self { max_amount , max_value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateLastRestartedSlotArguments { } impl UpdateLastRestartedSlotArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigArguments { pub key : String , pub value : u128 , } impl UpdateMarketConfigArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (value , rest1) = read_u128 (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigFlagArguments { pub key : String , pub value : bool , } impl UpdateMarketConfigFlagArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; let (value , rest1) = read_bool (data) ? ; data = rest1 ; Ok ((Self { key , value } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateMarketConfigWithBufferArguments { } impl UpdateMarketConfigWithBufferArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { Ok ((Self { } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateOrderArguments { pub params : UpdateOrderParams , } impl UpdateOrderArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = UpdateOrderParams :: read (data) ? ; data = rest1 ; Ok ((Self { params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateOrderV2Arguments { pub params : UpdateOrderParams , } impl UpdateOrderV2Arguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (params , rest1) = UpdateOrderParams :: read (data) ? ; data = rest1 ; Ok ((Self { params } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdatePriceFeedWithChainlinkArguments { pub compressed_report : Vec < u8 > , } impl UpdatePriceFeedWithChainlinkArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "bytes") ; ; Ok ((Self { compressed_report } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UpdateTokenMetadataArguments { pub name : String , pub symbol : String , pub uri : String , } impl UpdateTokenMetadataArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { anyhow :: bail ! ("unsupported type: {}" , "string") ; ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; anyhow :: bail ! ("unsupported type: {}" , "string") ; ; Ok ((Self { name , symbol , uri } , data)) } } # [derive (Debug , serde :: Serialize)] pub struct UseClaimableAccountArguments { pub timestamp : i64 , pub amount : u64 , } impl UseClaimableAccountArguments { pub fn read (mut data : & [u8]) -> anyhow :: Result < (Self , & [u8]) > { let (timestamp , rest1) = read_i64 (data) ? ; data = rest1 ; let (amount , rest1) = read_u64 (data) ? ; data = rest1 ; Ok ((Self { timestamp , amount } , data)) } } } # [derive (Debug , serde :: Serialize)] # [serde (tag = "instruction_type")] pub enum Instruction { AcceptReceiver { accounts : AcceptReceiverAccounts , args : AcceptReceiverArguments } , , AcceptReferralCode { accounts : AcceptReferralCodeAccounts , args : AcceptReferralCodeArguments } , , AcceptStoreAuthority { accounts : AcceptStoreAuthorityAccounts , args : AcceptStoreAuthorityArguments } , , AutoDeleverage { accounts : AutoDeleverageAccounts , args : AutoDeleverageArguments } , , CancelOrderIfNoPosition { accounts : CancelOrderIfNoPositionAccounts , args : CancelOrderIfNoPositionArguments } , , CancelReferralCodeTransfer { accounts : CancelReferralCodeTransferAccounts , args : CancelReferralCodeTransferArguments } , , CheckAdmin { accounts : CheckAdminAccounts , args : CheckAdminArguments } , , CheckRole { accounts : CheckRoleAccounts , args : CheckRoleArguments } , , ClaimFeesFromMarket { accounts : ClaimFeesFromMarketAccounts , args : ClaimFeesFromMarketArguments } , , ClearAllPrices { accounts : ClearAllPricesAccounts , args : ClearAllPricesArguments } , , CloseDeposit { accounts : CloseDepositAccounts , args : CloseDepositArguments } , , CloseEmptyClaimableAccount { accounts : CloseEmptyClaimableAccountAccounts , args : CloseEmptyClaimableAccountArguments } , , CloseGlvDeposit { accounts : CloseGlvDepositAccounts , args : CloseGlvDepositArguments } , , CloseGlvShift { accounts : CloseGlvShiftAccounts , args : CloseGlvShiftArguments } , , CloseGlvWithdrawal { accounts : CloseGlvWithdrawalAccounts , args : CloseGlvWithdrawalArguments } , , CloseGtExchange { accounts : CloseGtExchangeAccounts , args : CloseGtExchangeArguments } , , CloseMarketConfigBuffer { accounts : CloseMarketConfigBufferAccounts , args : CloseMarketConfigBufferArguments } , , CloseOrder { accounts : CloseOrderAccounts , args : CloseOrderArguments } , , CloseOrderV2 { accounts : CloseOrderV2Accounts , args : CloseOrderV2Arguments } , , CloseShift { accounts : CloseShiftAccounts , args : CloseShiftArguments } , , CloseVirtualInventory { accounts : CloseVirtualInventoryAccounts , args : CloseVirtualInventoryArguments } , , CloseWithdrawal { accounts : CloseWithdrawalAccounts , args : CloseWithdrawalArguments } , , ConfirmGtExchangeVault { accounts : ConfirmGtExchangeVaultAccounts , args : ConfirmGtExchangeVaultArguments } , , ConfirmGtExchangeVaultV2 { accounts : ConfirmGtExchangeVaultV2Accounts , args : ConfirmGtExchangeVaultV2Arguments } , , CreateDeposit { accounts : CreateDepositAccounts , args : CreateDepositArguments } , , CreateGlvDeposit { accounts : CreateGlvDepositAccounts , args : CreateGlvDepositArguments } , , CreateGlvShift { accounts : CreateGlvShiftAccounts , args : CreateGlvShiftArguments } , , CreateGlvWithdrawal { accounts : CreateGlvWithdrawalAccounts , args : CreateGlvWithdrawalArguments } , , CreateOrder { accounts : CreateOrderAccounts , args : CreateOrderArguments } , , CreateOrderV2 { accounts : CreateOrderV2Accounts , args : CreateOrderV2Arguments } , , CreateShift { accounts : CreateShiftAccounts , args : CreateShiftArguments } , , CreateTokenMetadata { accounts : CreateTokenMetadataAccounts , args : CreateTokenMetadataArguments } , , CreateVirtualInventoryForPositions { accounts : CreateVirtualInventoryForPositionsAccounts , args : CreateVirtualInventoryForPositionsArguments } , , CreateVirtualInventoryForSwaps { accounts : CreateVirtualInventoryForSwapsAccounts , args : CreateVirtualInventoryForSwapsArguments } , , CreateWithdrawal { accounts : CreateWithdrawalAccounts , args : CreateWithdrawalArguments } , , DisableRole { accounts : DisableRoleAccounts , args : DisableRoleArguments } , , DisableVirtualInventory { accounts : DisableVirtualInventoryAccounts , args : DisableVirtualInventoryArguments } , , EnableRole { accounts : EnableRoleAccounts , args : EnableRoleArguments } , , ExecuteDecreaseOrder { accounts : ExecuteDecreaseOrderAccounts , args : ExecuteDecreaseOrderArguments } , , ExecuteDecreaseOrderV2 { accounts : ExecuteDecreaseOrderV2Accounts , args : ExecuteDecreaseOrderV2Arguments } , , ExecuteDeposit { accounts : ExecuteDepositAccounts , args : ExecuteDepositArguments } , , ExecuteGlvDeposit { accounts : ExecuteGlvDepositAccounts , args : ExecuteGlvDepositArguments } , , ExecuteGlvShift { accounts : ExecuteGlvShiftAccounts , args : ExecuteGlvShiftArguments } , , ExecuteGlvWithdrawal { accounts : ExecuteGlvWithdrawalAccounts , args : ExecuteGlvWithdrawalArguments } , , ExecuteIncreaseOrSwapOrder { accounts : ExecuteIncreaseOrSwapOrderAccounts , args : ExecuteIncreaseOrSwapOrderArguments } , , ExecuteIncreaseOrSwapOrderV2 { accounts : ExecuteIncreaseOrSwapOrderV2Accounts , args : ExecuteIncreaseOrSwapOrderV2Arguments } , , ExecuteShift { accounts : ExecuteShiftAccounts , args : ExecuteShiftArguments } , , ExecuteWithdrawal { accounts : ExecuteWithdrawalAccounts , args : ExecuteWithdrawalArguments } , , GetMarketStatus { accounts : GetMarketStatusAccounts , args : GetMarketStatusArguments } , , GetMarketTokenPrice { accounts : GetMarketTokenPriceAccounts , args : GetMarketTokenPriceArguments } , , GrantRole { accounts : GrantRoleAccounts , args : GrantRoleArguments } , , GtSetExchangeTimeWindow { accounts : GtSetExchangeTimeWindowAccounts , args : GtSetExchangeTimeWindowArguments } , , GtSetOrderFeeDiscountFactors { accounts : GtSetOrderFeeDiscountFactorsAccounts , args : GtSetOrderFeeDiscountFactorsArguments } , , GtSetReferralRewardFactors { accounts : GtSetReferralRewardFactorsAccounts , args : GtSetReferralRewardFactorsArguments } , , HasAdmin { accounts : HasAdminAccounts , args : HasAdminArguments } , , HasRole { accounts : HasRoleAccounts , args : HasRoleArguments } , , Initialize { accounts : InitializeAccounts , args : InitializeArguments } , , InitializeCallbackAuthority { accounts : InitializeCallbackAuthorityAccounts , args : InitializeCallbackAuthorityArguments } , , InitializeGlv { accounts : InitializeGlvAccounts , args : InitializeGlvArguments } , , InitializeGt { accounts : InitializeGtAccounts , args : InitializeGtArguments } , , InitializeMarket { accounts : InitializeMarketAccounts , args : InitializeMarketArguments } , , InitializeMarketConfigBuffer { accounts : InitializeMarketConfigBufferAccounts , args : InitializeMarketConfigBufferArguments } , , InitializeMarketVault { accounts : InitializeMarketVaultAccounts , args : InitializeMarketVaultArguments } , , InitializeOracle { accounts : InitializeOracleAccounts , args : InitializeOracleArguments } , , InitializePriceFeed { accounts : InitializePriceFeedAccounts , args : InitializePriceFeedArguments } , , InitializeReferralCode { accounts : InitializeReferralCodeAccounts , args : InitializeReferralCodeArguments } , , InitializeTokenMap { accounts : InitializeTokenMapAccounts , args : InitializeTokenMapArguments } , , InsertAddress { accounts : InsertAddressAccounts , args : InsertAddressArguments } , , InsertAmount { accounts : InsertAmountAccounts , args : InsertAmountArguments } , , InsertFactor { accounts : InsertFactorAccounts , args : InsertFactorArguments } , , InsertGlvMarket { accounts : InsertGlvMarketAccounts , args : InsertGlvMarketArguments } , , InsertOrderFeeDiscountForReferredUser { accounts : InsertOrderFeeDiscountForReferredUserAccounts , args : InsertOrderFeeDiscountForReferredUserArguments } , , IsTokenConfigEnabled { accounts : IsTokenConfigEnabledAccounts , args : IsTokenConfigEnabledArguments } , , JoinVirtualInventoryForPositions { accounts : JoinVirtualInventoryForPositionsAccounts , args : JoinVirtualInventoryForPositionsArguments } , , JoinVirtualInventoryForSwaps { accounts : JoinVirtualInventoryForSwapsAccounts , args : JoinVirtualInventoryForSwapsArguments } , , LeaveDisabledVirtualInventory { accounts : LeaveDisabledVirtualInventoryAccounts , args : LeaveDisabledVirtualInventoryArguments } , , LeaveVirtualInventoryForPositions { accounts : LeaveVirtualInventoryForPositionsAccounts , args : LeaveVirtualInventoryForPositionsArguments } , , LeaveVirtualInventoryForSwaps { accounts : LeaveVirtualInventoryForSwapsAccounts , args : LeaveVirtualInventoryForSwapsArguments } , , Liquidate { accounts : LiquidateAccounts , args : LiquidateArguments } , , MarketTransferIn { accounts : MarketTransferInAccounts , args : MarketTransferInArguments } , , MigrateReferralCode { accounts : MigrateReferralCodeAccounts , args : MigrateReferralCodeArguments } , , PrepareAssociatedTokenAccount { accounts : PrepareAssociatedTokenAccountAccounts , args : PrepareAssociatedTokenAccountArguments } , , PrepareGtExchangeVault { accounts : PrepareGtExchangeVaultAccounts , args : PrepareGtExchangeVaultArguments } , , PreparePosition { accounts : PreparePositionAccounts , args : PreparePositionArguments } , , PrepareTradeEventBuffer { accounts : PrepareTradeEventBufferAccounts , args : PrepareTradeEventBufferArguments } , , PrepareUser { accounts : PrepareUserAccounts , args : PrepareUserArguments } , , PushToMarketConfigBuffer { accounts : PushToMarketConfigBufferAccounts , args : PushToMarketConfigBufferArguments } , , PushToTokenMap { accounts : PushToTokenMapAccounts , args : PushToTokenMapArguments } , , PushToTokenMapSynthetic { accounts : PushToTokenMapSyntheticAccounts , args : PushToTokenMapSyntheticArguments } , , RemoveGlvMarket { accounts : RemoveGlvMarketAccounts , args : RemoveGlvMarketArguments } , , RequestGtExchange { accounts : RequestGtExchangeAccounts , args : RequestGtExchangeArguments } , , RevokeRole { accounts : RevokeRoleAccounts , args : RevokeRoleArguments } , , SetExpectedProvider { accounts : SetExpectedProviderAccounts , args : SetExpectedProviderArguments } , , SetFeedConfig { accounts : SetFeedConfigAccounts , args : SetFeedConfigArguments } , , SetFeedConfigV2 { accounts : SetFeedConfigV2Accounts , args : SetFeedConfigV2Arguments } , , SetMarketConfigBufferAuthority { accounts : SetMarketConfigBufferAuthorityAccounts , args : SetMarketConfigBufferAuthorityArguments } , , SetPricesFromPriceFeed { accounts : SetPricesFromPriceFeedAccounts , args : SetPricesFromPriceFeedArguments } , , SetReferrer { accounts : SetReferrerAccounts , args : SetReferrerArguments } , , SetTokenMap { accounts : SetTokenMapAccounts , args : SetTokenMapArguments } , , ToggleFeature { accounts : ToggleFeatureAccounts , args : ToggleFeatureArguments } , , ToggleGlvMarketFlag { accounts : ToggleGlvMarketFlagAccounts , args : ToggleGlvMarketFlagArguments } , , ToggleGtMinting { accounts : ToggleGtMintingAccounts , args : ToggleGtMintingArguments } , , ToggleMarket { accounts : ToggleMarketAccounts , args : ToggleMarketArguments } , , ToggleTokenConfig { accounts : ToggleTokenConfigAccounts , args : ToggleTokenConfigArguments } , , ToggleTokenPriceAdjustment { accounts : ToggleTokenPriceAdjustmentAccounts , args : ToggleTokenPriceAdjustmentArguments } , , TokenDecimals { accounts : TokenDecimalsAccounts , args : TokenDecimalsArguments } , , TokenExpectedProvider { accounts : TokenExpectedProviderAccounts , args : TokenExpectedProviderArguments } , , TokenFeed { accounts : TokenFeedAccounts , args : TokenFeedArguments } , , TokenName { accounts : TokenNameAccounts , args : TokenNameArguments } , , TokenPrecision { accounts : TokenPrecisionAccounts , args : TokenPrecisionArguments } , , TokenTimestampAdjustment { accounts : TokenTimestampAdjustmentAccounts , args : TokenTimestampAdjustmentArguments } , , TransferReceiver { accounts : TransferReceiverAccounts , args : TransferReceiverArguments } , , TransferReferralCode { accounts : TransferReferralCodeAccounts , args : TransferReferralCodeArguments } , , TransferStoreAuthority { accounts : TransferStoreAuthorityAccounts , args : TransferStoreAuthorityArguments } , , UpdateAdlState { accounts : UpdateAdlStateAccounts , args : UpdateAdlStateArguments } , , UpdateGlvConfig { accounts : UpdateGlvConfigAccounts , args : UpdateGlvConfigArguments } , , UpdateGlvMarketConfig { accounts : UpdateGlvMarketConfigAccounts , args : UpdateGlvMarketConfigArguments } , , UpdateLastRestartedSlot { accounts : UpdateLastRestartedSlotAccounts , args : UpdateLastRestartedSlotArguments } , , UpdateMarketConfig { accounts : UpdateMarketConfigAccounts , args : UpdateMarketConfigArguments } , , UpdateMarketConfigFlag { accounts : UpdateMarketConfigFlagAccounts , args : UpdateMarketConfigFlagArguments } , , UpdateMarketConfigWithBuffer { accounts : UpdateMarketConfigWithBufferAccounts , args : UpdateMarketConfigWithBufferArguments } , , UpdateOrder { accounts : UpdateOrderAccounts , args : UpdateOrderArguments } , , UpdateOrderV2 { accounts : UpdateOrderV2Accounts , args : UpdateOrderV2Arguments } , , UpdatePriceFeedWithChainlink { accounts : UpdatePriceFeedWithChainlinkAccounts , args : UpdatePriceFeedWithChainlinkArguments } , , UpdateTokenMetadata { accounts : UpdateTokenMetadataAccounts , args : UpdateTokenMetadataArguments } , , UseClaimableAccount { accounts : UseClaimableAccountAccounts , args : UseClaimableAccountArguments } , } impl Instruction { pub fn decode (account_keys : & [String] , data : & [u8]) -> anyhow :: Result < Self > { if data . len () < 8 { anyhow :: bail ! ("Data too short: {}" , data . len ()) } let (disc_slice , rest) = data . split_at (8) ; let disc : [u8 ; 8] = disc_slice . try_into () . unwrap () ; match disc { [93u8 , 246u8 , 187u8 , 244u8 , 111u8 , 155u8 , 186u8 , 235u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = AcceptReceiverArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let next_receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = AcceptReceiverAccounts { next_receiver , store , remaining } ; return Ok (Instruction :: AcceptReceiver { accounts , args }) ; } , [161u8 , 82u8 , 76u8 , 244u8 , 25u8 , 188u8 , 215u8 , 207u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = AcceptReferralCodeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let next_owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referral_code = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = AcceptReferralCodeAccounts { next_owner , store , user , referral_code , receiver_user , remaining } ; return Ok (Instruction :: AcceptReferralCode { accounts , args }) ; } , [19u8 , 118u8 , 2u8 , 20u8 , 10u8 , 118u8 , 118u8 , 208u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = AcceptStoreAuthorityArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let next_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = AcceptStoreAuthorityAccounts { next_authority , store , remaining } ; return Ok (Instruction :: AcceptStoreAuthority { accounts , args }) ; } , [210u8 , 69u8 , 163u8 , 148u8 , 44u8 , 245u8 , 226u8 , 170u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = AutoDeleverageArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_long_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_short_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_pnl_token_account_for_holding = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = AutoDeleverageAccounts { authority , owner , user , store , token_map , oracle , market , order , position , event , long_token , short_token , long_token_escrow , short_token_escrow , long_token_vault , short_token_vault , claimable_long_token_account_for_user , claimable_short_token_account_for_user , claimable_pnl_token_account_for_holding , system_program , token_program , associated_token_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: AutoDeleverage { accounts , args }) ; } , [41u8 , 140u8 , 160u8 , 127u8 , 168u8 , 138u8 , 4u8 , 28u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CancelOrderIfNoPositionArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CancelOrderIfNoPositionAccounts { authority , store , order , position , remaining } ; return Ok (Instruction :: CancelOrderIfNoPosition { accounts , args }) ; } , [161u8 , 31u8 , 77u8 , 170u8 , 104u8 , 11u8 , 96u8 , 19u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CancelReferralCodeTransferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referral_code = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CancelReferralCodeTransferAccounts { owner , store , user , referral_code , remaining } ; return Ok (Instruction :: CancelReferralCodeTransfer { accounts , args }) ; } , [207u8 , 152u8 , 134u8 , 45u8 , 235u8 , 115u8 , 54u8 , 186u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CheckAdminArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CheckAdminAccounts { authority , store , remaining } ; return Ok (Instruction :: CheckAdmin { accounts , args }) ; } , [142u8 , 221u8 , 97u8 , 79u8 , 34u8 , 70u8 , 95u8 , 203u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CheckRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CheckRoleAccounts { authority , store , remaining } ; return Ok (Instruction :: CheckRole { accounts , args }) ; } , [245u8 , 167u8 , 45u8 , 29u8 , 37u8 , 215u8 , 168u8 , 32u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ClaimFeesFromMarketArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let target = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ClaimFeesFromMarketAccounts { authority , store , market , token_mint , vault , target , token_program , event_authority , program , remaining } ; return Ok (Instruction :: ClaimFeesFromMarket { accounts , args }) ; } , [168u8 , 114u8 , 138u8 , 123u8 , 105u8 , 56u8 , 252u8 , 151u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ClearAllPricesArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ClearAllPricesAccounts { authority , store , oracle , remaining } ; return Ok (Instruction :: ClearAllPrices { accounts , args }) ; } , [200u8 , 19u8 , 254u8 , 192u8 , 15u8 , 110u8 , 209u8 , 179u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseDepositAccounts { executor , store , store_wallet , owner , receiver , market_token , initial_long_token , initial_short_token , deposit , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , market_token_ata , initial_long_token_ata , initial_short_token_ata , system_program , token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseDeposit { accounts , args }) ; } , [160u8 , 114u8 , 144u8 , 216u8 , 133u8 , 237u8 , 255u8 , 158u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseEmptyClaimableAccountArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseEmptyClaimableAccountAccounts { authority , store , mint , owner , account , system_program , token_program , remaining } ; return Ok (Instruction :: CloseEmptyClaimableAccount { accounts , args }) ; } , [23u8 , 131u8 , 155u8 , 5u8 , 79u8 , 73u8 , 74u8 , 247u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseGlvDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseGlvDepositAccounts { executor , store , store_wallet , owner , receiver , glv_deposit , market_token , initial_long_token , initial_short_token , glv_token , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , glv_token_escrow , market_token_ata , initial_long_token_ata , initial_short_token_ata , glv_token_ata , system_program , token_program , glv_token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseGlvDeposit { accounts , args }) ; } , [90u8 , 31u8 , 241u8 , 89u8 , 138u8 , 184u8 , 164u8 , 186u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseGlvShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let funder = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseGlvShiftAccounts { authority , funder , store , store_wallet , glv , glv_shift , from_market_token , to_market_token , system_program , token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseGlvShift { accounts , args }) ; } , [14u8 , 209u8 , 38u8 , 49u8 , 97u8 , 42u8 , 179u8 , 212u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseGlvWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseGlvWithdrawalAccounts { executor , store , store_wallet , owner , receiver , glv_withdrawal , market_token , final_long_token , final_short_token , glv_token , market_token_escrow , final_long_token_escrow , final_short_token_escrow , market_token_ata , final_long_token_ata , final_short_token_ata , glv_token_escrow , glv_token_ata , system_program , token_program , glv_token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseGlvWithdrawal { accounts , args }) ; } , [180u8 , 247u8 , 24u8 , 67u8 , 219u8 , 21u8 , 83u8 , 148u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseGtExchangeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let exchange = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseGtExchangeAccounts { authority , store , owner , vault , exchange , remaining } ; return Ok (Instruction :: CloseGtExchange { accounts , args }) ; } , [115u8 , 231u8 , 168u8 , 106u8 , 130u8 , 45u8 , 95u8 , 247u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseMarketConfigBufferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let buffer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseMarketConfigBufferAccounts { authority , buffer , receiver , remaining } ; return Ok (Instruction :: CloseMarketConfigBuffer { accounts , args }) ; } , [90u8 , 103u8 , 209u8 , 28u8 , 7u8 , 63u8 , 168u8 , 4u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseOrderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let rent_receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referrer_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseOrderAccounts { executor , store , store_wallet , owner , receiver , rent_receiver , user , referrer_user , order , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_ata , final_output_token_ata , long_token_ata , short_token_ata , system_program , token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseOrder { accounts , args }) ; } , [213u8 , 217u8 , 98u8 , 100u8 , 225u8 , 205u8 , 76u8 , 184u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseOrderV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let rent_receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referrer_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_shared_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_partitioned_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseOrderV2Accounts { executor , store , store_wallet , owner , receiver , rent_receiver , user , referrer_user , order , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_ata , final_output_token_ata , long_token_ata , short_token_ata , system_program , token_program , associated_token_program , callback_authority , callback_program , callback_shared_data_account , callback_partitioned_data_account , event_authority , program , remaining } ; return Ok (Instruction :: CloseOrderV2 { accounts , args }) ; } , [153u8 , 180u8 , 40u8 , 133u8 , 195u8 , 210u8 , 196u8 , 99u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseShiftAccounts { executor , store , store_wallet , owner , receiver , shift , from_market_token , to_market_token , from_market_token_escrow , to_market_token_escrow , from_market_token_ata , to_market_token_ata , system_program , token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseShift { accounts , args }) ; } , [129u8 , 32u8 , 26u8 , 3u8 , 42u8 , 164u8 , 6u8 , 210u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseVirtualInventoryArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseVirtualInventoryAccounts { authority , store , store_wallet , virtual_inventory , remaining } ; return Ok (Instruction :: CloseVirtualInventory { accounts , args }) ; } , [7u8 , 60u8 , 160u8 , 163u8 , 23u8 , 241u8 , 178u8 , 246u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CloseWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let executor = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CloseWithdrawalAccounts { executor , store , store_wallet , owner , receiver , market_token , final_long_token , final_short_token , withdrawal , market_token_escrow , final_long_token_escrow , final_short_token_escrow , market_token_ata , final_long_token_ata , final_short_token_ata , system_program , token_program , associated_token_program , event_authority , program , remaining } ; return Ok (Instruction :: CloseWithdrawal { accounts , args }) ; } , [128u8 , 248u8 , 235u8 , 107u8 , 86u8 , 76u8 , 2u8 , 170u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ConfirmGtExchangeVaultArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ConfirmGtExchangeVaultAccounts { authority , store , vault , event_authority , program , remaining } ; return Ok (Instruction :: ConfirmGtExchangeVault { accounts , args }) ; } , [248u8 , 171u8 , 118u8 , 202u8 , 159u8 , 186u8 , 236u8 , 43u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ConfirmGtExchangeVaultV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ConfirmGtExchangeVaultV2Accounts { authority , store , vault , event_authority , program , remaining } ; return Ok (Instruction :: ConfirmGtExchangeVaultV2 { accounts , args }) ; } , [157u8 , 30u8 , 11u8 , 129u8 , 16u8 , 166u8 , 115u8 , 75u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateDepositAccounts { owner , receiver , store , market , deposit , market_token , initial_long_token , initial_short_token , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , market_token_ata , initial_long_token_source , initial_short_token_source , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateDeposit { accounts , args }) ; } , [170u8 , 67u8 , 137u8 , 159u8 , 159u8 , 116u8 , 48u8 , 86u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateGlvDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateGlvDepositAccounts { owner , receiver , store , market , glv , glv_deposit , glv_token , market_token , initial_long_token , initial_short_token , market_token_source , initial_long_token_source , initial_short_token_source , glv_token_escrow , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , system_program , token_program , glv_token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateGlvDeposit { accounts , args }) ; } , [242u8 , 58u8 , 88u8 , 205u8 , 167u8 , 198u8 , 75u8 , 253u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateGlvShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateGlvShiftAccounts { authority , store , glv , from_market , to_market , glv_shift , from_market_token , to_market_token , from_market_token_vault , to_market_token_vault , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateGlvShift { accounts , args }) ; } , [25u8 , 224u8 , 16u8 , 45u8 , 95u8 , 39u8 , 208u8 , 35u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateGlvWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateGlvWithdrawalAccounts { owner , receiver , store , market , glv , glv_withdrawal , glv_token , market_token , final_long_token , final_short_token , glv_token_source , glv_token_escrow , market_token_escrow , final_long_token_escrow , final_short_token_escrow , system_program , token_program , glv_token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateGlvWithdrawal { accounts , args }) ; } , [141u8 , 54u8 , 37u8 , 207u8 , 237u8 , 210u8 , 250u8 , 215u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateOrderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateOrderAccounts { owner , receiver , store , market , user , order , position , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_source , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateOrder { accounts , args }) ; } , [200u8 , 157u8 , 3u8 , 182u8 , 3u8 , 164u8 , 162u8 , 240u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateOrderV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_shared_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_partitioned_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateOrderV2Accounts { owner , receiver , store , market , user , order , position , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_source , system_program , token_program , associated_token_program , callback_authority , callback_program , callback_shared_data_account , callback_partitioned_data_account , event_authority , program , remaining } ; return Ok (Instruction :: CreateOrderV2 { accounts , args }) ; } , [43u8 , 133u8 , 161u8 , 94u8 , 253u8 , 249u8 , 13u8 , 184u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateShiftAccounts { owner , receiver , store , from_market , to_market , shift , from_market_token , to_market_token , from_market_token_escrow , to_market_token_escrow , from_market_token_source , to_market_token_ata , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateShift { accounts , args }) ; } , [221u8 , 80u8 , 176u8 , 37u8 , 153u8 , 188u8 , 160u8 , 68u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateTokenMetadataArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let metadata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let sysvar_instructions = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let metadata_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateTokenMetadataAccounts { authority , store , mint , metadata , system_program , sysvar_instructions , metadata_program , remaining } ; return Ok (Instruction :: CreateTokenMetadata { accounts , args }) ; } , [114u8 , 86u8 , 241u8 , 91u8 , 247u8 , 80u8 , 64u8 , 107u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateVirtualInventoryForPositionsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let index_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateVirtualInventoryForPositionsAccounts { authority , store , index_token , virtual_inventory , system_program , remaining } ; return Ok (Instruction :: CreateVirtualInventoryForPositions { accounts , args }) ; } , [5u8 , 183u8 , 166u8 , 24u8 , 116u8 , 50u8 , 47u8 , 77u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateVirtualInventoryForSwapsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateVirtualInventoryForSwapsAccounts { authority , store , virtual_inventory , system_program , remaining } ; return Ok (Instruction :: CreateVirtualInventoryForSwaps { accounts , args }) ; } , [247u8 , 103u8 , 160u8 , 95u8 , 42u8 , 161u8 , 108u8 , 91u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = CreateWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_source = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = CreateWithdrawalAccounts { owner , receiver , store , market , withdrawal , market_token , final_long_token , final_short_token , market_token_escrow , final_long_token_escrow , final_short_token_escrow , market_token_source , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: CreateWithdrawal { accounts , args }) ; } , [211u8 , 224u8 , 245u8 , 96u8 , 179u8 , 213u8 , 176u8 , 26u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = DisableRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = DisableRoleAccounts { authority , store , remaining } ; return Ok (Instruction :: DisableRole { accounts , args }) ; } , [191u8 , 145u8 , 91u8 , 168u8 , 10u8 , 209u8 , 23u8 , 100u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = DisableVirtualInventoryArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = DisableVirtualInventoryAccounts { authority , store , virtual_inventory , remaining } ; return Ok (Instruction :: DisableVirtualInventory { accounts , args }) ; } , [154u8 , 1u8 , 249u8 , 148u8 , 155u8 , 80u8 , 118u8 , 115u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = EnableRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = EnableRoleAccounts { authority , store , remaining } ; return Ok (Instruction :: EnableRole { accounts , args }) ; } , [41u8 , 200u8 , 147u8 , 14u8 , 250u8 , 225u8 , 79u8 , 134u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteDecreaseOrderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_long_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_short_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_pnl_token_account_for_holding = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteDecreaseOrderAccounts { authority , store , token_map , oracle , market , owner , user , order , position , event , final_output_token , long_token , short_token , final_output_token_escrow , long_token_escrow , short_token_escrow , final_output_token_vault , long_token_vault , short_token_vault , claimable_long_token_account_for_user , claimable_short_token_account_for_user , claimable_pnl_token_account_for_holding , token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteDecreaseOrder { accounts , args }) ; } , [16u8 , 101u8 , 14u8 , 160u8 , 190u8 , 1u8 , 228u8 , 133u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteDecreaseOrderV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_long_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_short_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_pnl_token_account_for_holding = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_shared_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_partitioned_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteDecreaseOrderV2Accounts { authority , store , token_map , oracle , market , owner , user , order , position , event , final_output_token , long_token , short_token , final_output_token_escrow , long_token_escrow , short_token_escrow , final_output_token_vault , long_token_vault , short_token_vault , claimable_long_token_account_for_user , claimable_short_token_account_for_user , claimable_pnl_token_account_for_holding , token_program , system_program , callback_authority , callback_program , callback_shared_data_account , callback_partitioned_data_account , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteDecreaseOrderV2 { accounts , args }) ; } , [247u8 , 103u8 , 46u8 , 184u8 , 88u8 , 188u8 , 56u8 , 46u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteDepositAccounts { authority , store , token_map , oracle , market , deposit , market_token , initial_long_token , initial_short_token , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , initial_long_token_vault , initial_short_token_vault , token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteDeposit { accounts , args }) ; } , [18u8 , 81u8 , 214u8 , 21u8 , 82u8 , 232u8 , 148u8 , 177u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteGlvDepositArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_deposit = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteGlvDepositAccounts { authority , store , token_map , oracle , glv , market , glv_deposit , glv_token , market_token , initial_long_token , initial_short_token , glv_token_escrow , market_token_escrow , initial_long_token_escrow , initial_short_token_escrow , initial_long_token_vault , initial_short_token_vault , market_token_vault , token_program , glv_token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteGlvDeposit { accounts , args }) ; } , [209u8 , 190u8 , 175u8 , 51u8 , 144u8 , 98u8 , 45u8 , 201u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteGlvShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_glv_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_glv_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteGlvShiftAccounts { authority , store , token_map , oracle , glv , from_market , to_market , glv_shift , from_market_token , to_market_token , from_market_token_glv_vault , to_market_token_glv_vault , from_market_token_vault , token_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteGlvShift { accounts , args }) ; } , [161u8 , 145u8 , 255u8 , 200u8 , 224u8 , 8u8 , 183u8 , 135u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteGlvWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_withdrawal_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteGlvWithdrawalAccounts { authority , store , token_map , oracle , glv , market , glv_withdrawal , glv_token , market_token , final_long_token , final_short_token , glv_token_escrow , market_token_escrow , final_long_token_escrow , final_short_token_escrow , market_token_withdrawal_vault , final_long_token_vault , final_short_token_vault , market_token_vault , token_program , glv_token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteGlvWithdrawal { accounts , args }) ; } , [231u8 , 30u8 , 166u8 , 1u8 , 233u8 , 69u8 , 152u8 , 133u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteIncreaseOrSwapOrderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteIncreaseOrSwapOrderAccounts { authority , store , token_map , oracle , market , owner , user , order , position , event , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_vault , final_output_token_vault , long_token_vault , short_token_vault , token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteIncreaseOrSwapOrder { accounts , args }) ; } , [159u8 , 126u8 , 194u8 , 5u8 , 92u8 , 107u8 , 199u8 , 183u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteIncreaseOrSwapOrderV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let initial_collateral_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_output_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_shared_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_partitioned_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteIncreaseOrSwapOrderV2Accounts { authority , store , token_map , oracle , market , owner , user , order , position , event , initial_collateral_token , final_output_token , long_token , short_token , initial_collateral_token_escrow , final_output_token_escrow , long_token_escrow , short_token_escrow , initial_collateral_token_vault , final_output_token_vault , long_token_vault , short_token_vault , token_program , system_program , callback_authority , callback_program , callback_shared_data_account , callback_partitioned_data_account , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteIncreaseOrSwapOrderV2 { accounts , args }) ; } , [46u8 , 112u8 , 104u8 , 8u8 , 96u8 , 157u8 , 222u8 , 253u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteShiftArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let shift = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let to_market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteShiftAccounts { authority , store , token_map , oracle , from_market , to_market , shift , from_market_token , to_market_token , from_market_token_escrow , to_market_token_escrow , from_market_token_vault , token_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteShift { accounts , args }) ; } , [113u8 , 121u8 , 203u8 , 232u8 , 137u8 , 139u8 , 248u8 , 249u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ExecuteWithdrawalArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let withdrawal = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let final_short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ExecuteWithdrawalAccounts { authority , store , token_map , oracle , market , withdrawal , market_token , final_long_token , final_short_token , market_token_escrow , final_long_token_escrow , final_short_token_escrow , market_token_vault , final_long_token_vault , final_short_token_vault , token_program , system_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: ExecuteWithdrawal { accounts , args }) ; } , [51u8 , 68u8 , 212u8 , 8u8 , 4u8 , 23u8 , 221u8 , 91u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GetMarketStatusArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GetMarketStatusAccounts { market , remaining } ; return Ok (Instruction :: GetMarketStatus { accounts , args }) ; } , [60u8 , 217u8 , 40u8 , 2u8 , 12u8 , 236u8 , 254u8 , 199u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GetMarketTokenPriceArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GetMarketTokenPriceAccounts { market , market_token , remaining } ; return Ok (Instruction :: GetMarketTokenPrice { accounts , args }) ; } , [218u8 , 234u8 , 128u8 , 15u8 , 82u8 , 33u8 , 236u8 , 253u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GrantRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GrantRoleAccounts { authority , store , remaining } ; return Ok (Instruction :: GrantRole { accounts , args }) ; } , [148u8 , 155u8 , 45u8 , 52u8 , 154u8 , 67u8 , 248u8 , 129u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GtSetExchangeTimeWindowArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GtSetExchangeTimeWindowAccounts { authority , store , remaining } ; return Ok (Instruction :: GtSetExchangeTimeWindow { accounts , args }) ; } , [234u8 , 198u8 , 196u8 , 44u8 , 93u8 , 2u8 , 1u8 , 150u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GtSetOrderFeeDiscountFactorsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GtSetOrderFeeDiscountFactorsAccounts { authority , store , remaining } ; return Ok (Instruction :: GtSetOrderFeeDiscountFactors { accounts , args }) ; } , [165u8 , 230u8 , 7u8 , 217u8 , 91u8 , 156u8 , 185u8 , 64u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = GtSetReferralRewardFactorsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = GtSetReferralRewardFactorsAccounts { authority , store , remaining } ; return Ok (Instruction :: GtSetReferralRewardFactors { accounts , args }) ; } , [254u8 , 220u8 , 34u8 , 140u8 , 38u8 , 82u8 , 235u8 , 42u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = HasAdminArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = HasAdminAccounts { store , remaining } ; return Ok (Instruction :: HasAdmin { accounts , args }) ; } , [218u8 , 136u8 , 44u8 , 87u8 , 142u8 , 247u8 , 141u8 , 195u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = HasRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = HasRoleAccounts { store , remaining } ; return Ok (Instruction :: HasRole { accounts , args }) ; } , [175u8 , 175u8 , 109u8 , 31u8 , 13u8 , 152u8 , 155u8 , 237u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let holding = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeAccounts { payer , authority , receiver , holding , store , system_program , remaining } ; return Ok (Instruction :: Initialize { accounts , args }) ; } , [110u8 , 241u8 , 211u8 , 153u8 , 40u8 , 189u8 , 45u8 , 180u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeCallbackAuthorityArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeCallbackAuthorityAccounts { payer , callback_authority , system_program , remaining } ; return Ok (Instruction :: InitializeCallbackAuthority { accounts , args }) ; } , [175u8 , 40u8 , 40u8 , 75u8 , 146u8 , 192u8 , 27u8 , 112u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeGlvArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeGlvAccounts { authority , store , glv_token , glv , system_program , token_program , market_token_program , associated_token_program , remaining } ; return Ok (Instruction :: InitializeGlv { accounts , args }) ; } , [208u8 , 0u8 , 173u8 , 158u8 , 133u8 , 227u8 , 247u8 , 47u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeGtArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeGtAccounts { authority , store , system_program , remaining } ; return Ok (Instruction :: InitializeGt { accounts , args }) ; } , [35u8 , 35u8 , 189u8 , 193u8 , 155u8 , 48u8 , 170u8 , 203u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeMarketArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token_mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeMarketAccounts { authority , store , market_token_mint , long_token_mint , short_token_mint , market , token_map , long_token_vault , short_token_vault , system_program , token_program , remaining } ; return Ok (Instruction :: InitializeMarket { accounts , args }) ; } , [146u8 , 13u8 , 232u8 , 205u8 , 56u8 , 48u8 , 11u8 , 48u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeMarketConfigBufferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let buffer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeMarketConfigBufferAccounts { authority , store , buffer , system_program , remaining } ; return Ok (Instruction :: InitializeMarketConfigBuffer { accounts , args }) ; } , [25u8 , 102u8 , 203u8 , 119u8 , 151u8 , 20u8 , 143u8 , 222u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeMarketVaultArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeMarketVaultAccounts { authority , store , mint , vault , system_program , token_program , remaining } ; return Ok (Instruction :: InitializeMarketVault { accounts , args }) ; } , [144u8 , 223u8 , 131u8 , 120u8 , 196u8 , 253u8 , 181u8 , 99u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeOracleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeOracleAccounts { payer , authority , store , oracle , system_program , remaining } ; return Ok (Instruction :: InitializeOracle { accounts , args }) ; } , [68u8 , 180u8 , 81u8 , 20u8 , 102u8 , 213u8 , 145u8 , 233u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializePriceFeedArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let price_feed = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializePriceFeedAccounts { authority , store , price_feed , system_program , remaining } ; return Ok (Instruction :: InitializePriceFeed { accounts , args }) ; } , [79u8 , 123u8 , 26u8 , 247u8 , 241u8 , 74u8 , 176u8 , 20u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeReferralCodeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referral_code = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeReferralCodeAccounts { owner , store , referral_code , user , system_program , remaining } ; return Ok (Instruction :: InitializeReferralCode { accounts , args }) ; } , [28u8 , 80u8 , 213u8 , 31u8 , 142u8 , 225u8 , 116u8 , 117u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InitializeTokenMapArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InitializeTokenMapAccounts { payer , store , token_map , system_program , remaining } ; return Ok (Instruction :: InitializeTokenMap { accounts , args }) ; } , [119u8 , 10u8 , 254u8 , 2u8 , 233u8 , 216u8 , 218u8 , 152u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InsertAddressArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InsertAddressAccounts { authority , store , remaining } ; return Ok (Instruction :: InsertAddress { accounts , args }) ; } , [56u8 , 254u8 , 136u8 , 216u8 , 68u8 , 134u8 , 2u8 , 144u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InsertAmountArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InsertAmountAccounts { authority , store , remaining } ; return Ok (Instruction :: InsertAmount { accounts , args }) ; } , [56u8 , 41u8 , 238u8 , 140u8 , 172u8 , 21u8 , 108u8 , 230u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InsertFactorArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InsertFactorAccounts { authority , store , remaining } ; return Ok (Instruction :: InsertFactor { accounts , args }) ; } , [31u8 , 15u8 , 125u8 , 218u8 , 90u8 , 89u8 , 81u8 , 75u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InsertGlvMarketArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InsertGlvMarketAccounts { authority , store , glv , market_token , market , vault , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: InsertGlvMarket { accounts , args }) ; } , [54u8 , 88u8 , 208u8 , 238u8 , 242u8 , 83u8 , 99u8 , 66u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = InsertOrderFeeDiscountForReferredUserArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = InsertOrderFeeDiscountForReferredUserAccounts { authority , store , remaining } ; return Ok (Instruction :: InsertOrderFeeDiscountForReferredUser { accounts , args }) ; } , [150u8 , 121u8 , 104u8 , 152u8 , 174u8 , 109u8 , 137u8 , 136u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = IsTokenConfigEnabledArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = IsTokenConfigEnabledAccounts { token_map , remaining } ; return Ok (Instruction :: IsTokenConfigEnabled { accounts , args }) ; } , [49u8 , 213u8 , 202u8 , 84u8 , 201u8 , 143u8 , 157u8 , 64u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = JoinVirtualInventoryForPositionsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = JoinVirtualInventoryForPositionsAccounts { authority , store , virtual_inventory , market , remaining } ; return Ok (Instruction :: JoinVirtualInventoryForPositions { accounts , args }) ; } , [189u8 , 94u8 , 220u8 , 120u8 , 253u8 , 123u8 , 20u8 , 134u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = JoinVirtualInventoryForSwapsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = JoinVirtualInventoryForSwapsAccounts { authority , store , token_map , virtual_inventory , market , remaining } ; return Ok (Instruction :: JoinVirtualInventoryForSwaps { accounts , args }) ; } , [76u8 , 215u8 , 228u8 , 106u8 , 213u8 , 138u8 , 215u8 , 146u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = LeaveDisabledVirtualInventoryArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = LeaveDisabledVirtualInventoryAccounts { authority , store , virtual_inventory , market , remaining } ; return Ok (Instruction :: LeaveDisabledVirtualInventory { accounts , args }) ; } , [177u8 , 100u8 , 253u8 , 94u8 , 158u8 , 199u8 , 45u8 , 16u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = LeaveVirtualInventoryForPositionsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = LeaveVirtualInventoryForPositionsAccounts { authority , store , virtual_inventory , market , remaining } ; return Ok (Instruction :: LeaveVirtualInventoryForPositions { accounts , args }) ; } , [252u8 , 205u8 , 252u8 , 13u8 , 120u8 , 253u8 , 211u8 , 131u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = LeaveVirtualInventoryForSwapsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let virtual_inventory = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = LeaveVirtualInventoryForSwapsAccounts { authority , store , virtual_inventory , market , remaining } ; return Ok (Instruction :: LeaveVirtualInventoryForSwaps { accounts , args }) ; } , [223u8 , 179u8 , 226u8 , 125u8 , 48u8 , 46u8 , 39u8 , 74u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = LiquidateArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_escrow = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let long_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let short_token_vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_long_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_short_token_account_for_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let claimable_pnl_token_account_for_holding = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = LiquidateAccounts { authority , owner , user , store , token_map , oracle , market , order , position , event , long_token , short_token , long_token_escrow , short_token_escrow , long_token_vault , short_token_vault , claimable_long_token_account_for_user , claimable_short_token_account_for_user , claimable_pnl_token_account_for_holding , system_program , token_program , associated_token_program , chainlink_program , event_authority , program , remaining } ; return Ok (Instruction :: Liquidate { accounts , args }) ; } , [177u8 , 41u8 , 34u8 , 195u8 , 160u8 , 64u8 , 216u8 , 147u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = MarketTransferInArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let from = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = MarketTransferInAccounts { authority , store , from_authority , market , from , vault , token_program , event_authority , program , remaining } ; return Ok (Instruction :: MarketTransferIn { accounts , args }) ; } , [32u8 , 248u8 , 199u8 , 115u8 , 236u8 , 124u8 , 65u8 , 140u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = MigrateReferralCodeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = MigrateReferralCodeAccounts { authority , store , system , remaining } ; return Ok (Instruction :: MigrateReferralCode { accounts , args }) ; } , [28u8 , 102u8 , 183u8 , 89u8 , 155u8 , 198u8 , 28u8 , 0u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PrepareAssociatedTokenAccountArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PrepareAssociatedTokenAccountAccounts { payer , owner , mint , account , system_program , token_program , associated_token_program , remaining } ; return Ok (Instruction :: PrepareAssociatedTokenAccount { accounts , args }) ; } , [18u8 , 155u8 , 190u8 , 88u8 , 59u8 , 109u8 , 0u8 , 253u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PrepareGtExchangeVaultArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let payer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PrepareGtExchangeVaultAccounts { payer , store , vault , system_program , remaining } ; return Ok (Instruction :: PrepareGtExchangeVault { accounts , args }) ; } , [178u8 , 215u8 , 55u8 , 90u8 , 137u8 , 15u8 , 108u8 , 15u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PreparePositionArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let position = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PreparePositionAccounts { owner , store , market , position , system_program , remaining } ; return Ok (Instruction :: PreparePosition { accounts , args }) ; } , [142u8 , 10u8 , 203u8 , 67u8 , 106u8 , 166u8 , 50u8 , 135u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PrepareTradeEventBufferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PrepareTradeEventBufferAccounts { authority , store , event , system_program , remaining } ; return Ok (Instruction :: PrepareTradeEventBuffer { accounts , args }) ; } , [190u8 , 173u8 , 143u8 , 193u8 , 139u8 , 80u8 , 231u8 , 133u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PrepareUserArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PrepareUserAccounts { owner , store , user , system_program , remaining } ; return Ok (Instruction :: PrepareUser { accounts , args }) ; } , [91u8 , 58u8 , 203u8 , 22u8 , 242u8 , 135u8 , 100u8 , 245u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PushToMarketConfigBufferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let buffer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PushToMarketConfigBufferAccounts { authority , buffer , system_program , remaining } ; return Ok (Instruction :: PushToMarketConfigBuffer { accounts , args }) ; } , [90u8 , 1u8 , 207u8 , 212u8 , 230u8 , 216u8 , 131u8 , 18u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PushToTokenMapArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PushToTokenMapAccounts { authority , store , token_map , token , system_program , remaining } ; return Ok (Instruction :: PushToTokenMap { accounts , args }) ; } , [157u8 , 152u8 , 190u8 , 7u8 , 162u8 , 194u8 , 61u8 , 237u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = PushToTokenMapSyntheticArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = PushToTokenMapSyntheticAccounts { authority , store , token_map , system_program , remaining } ; return Ok (Instruction :: PushToTokenMapSynthetic { accounts , args }) ; } , [179u8 , 99u8 , 98u8 , 104u8 , 139u8 , 13u8 , 225u8 , 231u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = RemoveGlvMarketArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store_wallet_ata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let associated_token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = RemoveGlvMarketAccounts { authority , store , store_wallet , glv , market_token , vault , store_wallet_ata , token_program , associated_token_program , system_program , remaining } ; return Ok (Instruction :: RemoveGlvMarket { accounts , args }) ; } , [117u8 , 72u8 , 255u8 , 69u8 , 200u8 , 107u8 , 238u8 , 88u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = RequestGtExchangeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let vault = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let exchange = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = RequestGtExchangeAccounts { owner , store , user , vault , exchange , system_program , event_authority , program , remaining } ; return Ok (Instruction :: RequestGtExchange { accounts , args }) ; } , [179u8 , 232u8 , 2u8 , 180u8 , 48u8 , 227u8 , 82u8 , 7u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = RevokeRoleArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = RevokeRoleAccounts { authority , store , remaining } ; return Ok (Instruction :: RevokeRole { accounts , args }) ; } , [68u8 , 133u8 , 150u8 , 156u8 , 99u8 , 0u8 , 42u8 , 25u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetExpectedProviderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetExpectedProviderAccounts { authority , store , token_map , remaining } ; return Ok (Instruction :: SetExpectedProvider { accounts , args }) ; } , [154u8 , 210u8 , 174u8 , 54u8 , 7u8 , 47u8 , 57u8 , 18u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetFeedConfigArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetFeedConfigAccounts { authority , store , token_map , remaining } ; return Ok (Instruction :: SetFeedConfig { accounts , args }) ; } , [137u8 , 164u8 , 163u8 , 145u8 , 66u8 , 101u8 , 139u8 , 77u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetFeedConfigV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetFeedConfigV2Accounts { authority , store , token_map , remaining } ; return Ok (Instruction :: SetFeedConfigV2 { accounts , args }) ; } , [113u8 , 56u8 , 17u8 , 219u8 , 126u8 , 137u8 , 28u8 , 83u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetMarketConfigBufferAuthorityArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let buffer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetMarketConfigBufferAuthorityAccounts { authority , buffer , remaining } ; return Ok (Instruction :: SetMarketConfigBufferAuthority { accounts , args }) ; } , [112u8 , 75u8 , 103u8 , 161u8 , 71u8 , 192u8 , 245u8 , 246u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetPricesFromPriceFeedArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetPricesFromPriceFeedAccounts { authority , store , oracle , token_map , chainlink_program , remaining } ; return Ok (Instruction :: SetPricesFromPriceFeed { accounts , args }) ; } , [115u8 , 251u8 , 55u8 , 0u8 , 166u8 , 189u8 , 25u8 , 74u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetReferrerArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referral_code = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referrer_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetReferrerAccounts { owner , store , user , referral_code , referrer_user , remaining } ; return Ok (Instruction :: SetReferrer { accounts , args }) ; } , [45u8 , 60u8 , 238u8 , 74u8 , 66u8 , 250u8 , 250u8 , 67u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = SetTokenMapArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = SetTokenMapAccounts { authority , store , token_map , remaining } ; return Ok (Instruction :: SetTokenMap { accounts , args }) ; } , [207u8 , 110u8 , 186u8 , 36u8 , 165u8 , 235u8 , 150u8 , 105u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleFeatureArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleFeatureAccounts { authority , store , remaining } ; return Ok (Instruction :: ToggleFeature { accounts , args }) ; } , [223u8 , 156u8 , 69u8 , 160u8 , 7u8 , 197u8 , 9u8 , 234u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleGlvMarketFlagArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleGlvMarketFlagAccounts { authority , store , glv , market_token , remaining } ; return Ok (Instruction :: ToggleGlvMarketFlag { accounts , args }) ; } , [117u8 , 30u8 , 81u8 , 109u8 , 66u8 , 100u8 , 230u8 , 75u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleGtMintingArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleGtMintingAccounts { authority , store , market , remaining } ; return Ok (Instruction :: ToggleGtMinting { accounts , args }) ; } , [185u8 , 244u8 , 78u8 , 180u8 , 171u8 , 226u8 , 75u8 , 210u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleMarketArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleMarketAccounts { authority , store , market , remaining } ; return Ok (Instruction :: ToggleMarket { accounts , args }) ; } , [70u8 , 151u8 , 161u8 , 131u8 , 178u8 , 81u8 , 114u8 , 51u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleTokenConfigArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleTokenConfigAccounts { authority , store , token_map , remaining } ; return Ok (Instruction :: ToggleTokenConfig { accounts , args }) ; } , [114u8 , 128u8 , 20u8 , 220u8 , 204u8 , 29u8 , 111u8 , 189u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = ToggleTokenPriceAdjustmentArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = ToggleTokenPriceAdjustmentAccounts { authority , store , token_map , remaining } ; return Ok (Instruction :: ToggleTokenPriceAdjustment { accounts , args }) ; } , [167u8 , 171u8 , 85u8 , 147u8 , 131u8 , 122u8 , 3u8 , 161u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenDecimalsArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenDecimalsAccounts { token_map , remaining } ; return Ok (Instruction :: TokenDecimals { accounts , args }) ; } , [17u8 , 189u8 , 13u8 , 24u8 , 175u8 , 140u8 , 220u8 , 70u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenExpectedProviderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenExpectedProviderAccounts { token_map , remaining } ; return Ok (Instruction :: TokenExpectedProvider { accounts , args }) ; } , [178u8 , 76u8 , 209u8 , 235u8 , 176u8 , 9u8 , 216u8 , 71u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenFeedArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenFeedAccounts { token_map , remaining } ; return Ok (Instruction :: TokenFeed { accounts , args }) ; } , [60u8 , 216u8 , 194u8 , 86u8 , 103u8 , 127u8 , 130u8 , 237u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenNameArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenNameAccounts { token_map , remaining } ; return Ok (Instruction :: TokenName { accounts , args }) ; } , [133u8 , 90u8 , 219u8 , 89u8 , 70u8 , 161u8 , 16u8 , 153u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenPrecisionArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenPrecisionAccounts { token_map , remaining } ; return Ok (Instruction :: TokenPrecision { accounts , args }) ; } , [167u8 , 181u8 , 240u8 , 191u8 , 105u8 , 0u8 , 107u8 , 172u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TokenTimestampAdjustmentArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TokenTimestampAdjustmentAccounts { token_map , remaining } ; return Ok (Instruction :: TokenTimestampAdjustment { accounts , args }) ; } , [198u8 , 147u8 , 229u8 , 126u8 , 135u8 , 119u8 , 134u8 , 77u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TransferReceiverArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let next_receiver = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TransferReceiverAccounts { authority , store , next_receiver , remaining } ; return Ok (Instruction :: TransferReceiver { accounts , args }) ; } , [249u8 , 29u8 , 27u8 , 219u8 , 157u8 , 16u8 , 30u8 , 35u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TransferReferralCodeArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let referral_code = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let receiver_user = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TransferReferralCodeAccounts { owner , store , user , referral_code , receiver_user , remaining } ; return Ok (Instruction :: TransferReferralCode { accounts , args }) ; } , [184u8 , 159u8 , 201u8 , 3u8 , 112u8 , 253u8 , 7u8 , 215u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = TransferStoreAuthorityArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let next_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = TransferStoreAuthorityAccounts { authority , store , next_authority , remaining } ; return Ok (Instruction :: TransferStoreAuthority { accounts , args }) ; } , [12u8 , 45u8 , 19u8 , 113u8 , 13u8 , 43u8 , 203u8 , 232u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateAdlStateArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_map = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let oracle = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateAdlStateAccounts { authority , store , token_map , oracle , market , chainlink_program , remaining } ; return Ok (Instruction :: UpdateAdlState { accounts , args }) ; } , [0u8 , 248u8 , 95u8 , 167u8 , 0u8 , 115u8 , 252u8 , 252u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateGlvConfigArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateGlvConfigAccounts { authority , store , glv , remaining } ; return Ok (Instruction :: UpdateGlvConfig { accounts , args }) ; } , [57u8 , 244u8 , 68u8 , 250u8 , 222u8 , 31u8 , 209u8 , 198u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateGlvMarketConfigArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let glv = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market_token = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateGlvMarketConfigAccounts { authority , store , glv , market_token , remaining } ; return Ok (Instruction :: UpdateGlvMarketConfig { accounts , args }) ; } , [119u8 , 200u8 , 55u8 , 6u8 , 123u8 , 88u8 , 74u8 , 247u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateLastRestartedSlotArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateLastRestartedSlotAccounts { authority , store , remaining } ; return Ok (Instruction :: UpdateLastRestartedSlot { accounts , args }) ; } , [91u8 , 87u8 , 149u8 , 101u8 , 110u8 , 116u8 , 16u8 , 120u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateMarketConfigArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateMarketConfigAccounts { authority , store , market , remaining } ; return Ok (Instruction :: UpdateMarketConfig { accounts , args }) ; } , [34u8 , 138u8 , 223u8 , 216u8 , 120u8 , 146u8 , 126u8 , 151u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateMarketConfigFlagArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateMarketConfigFlagAccounts { authority , store , market , remaining } ; return Ok (Instruction :: UpdateMarketConfigFlag { accounts , args }) ; } , [62u8 , 102u8 , 20u8 , 4u8 , 35u8 , 174u8 , 195u8 , 46u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateMarketConfigWithBufferArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let buffer = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateMarketConfigWithBufferAccounts { authority , store , market , buffer , remaining } ; return Ok (Instruction :: UpdateMarketConfigWithBuffer { accounts , args }) ; } , [54u8 , 8u8 , 208u8 , 207u8 , 34u8 , 134u8 , 239u8 , 168u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateOrderArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateOrderAccounts { owner , store , market , order , remaining } ; return Ok (Instruction :: UpdateOrder { accounts , args }) ; } , [195u8 , 175u8 , 207u8 , 33u8 , 171u8 , 246u8 , 41u8 , 176u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateOrderV2Arguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let market = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let order = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_shared_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let callback_partitioned_data_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let event_authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateOrderV2Accounts { owner , store , market , order , callback_authority , callback_program , callback_shared_data_account , callback_partitioned_data_account , event_authority , program , remaining } ; return Ok (Instruction :: UpdateOrderV2 { accounts , args }) ; } , [204u8 , 69u8 , 132u8 , 33u8 , 153u8 , 43u8 , 6u8 , 148u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdatePriceFeedWithChainlinkArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let verifier_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let access_controller = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let config_account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let price_feed = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let chainlink = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdatePriceFeedWithChainlinkAccounts { authority , store , verifier_account , access_controller , config_account , price_feed , chainlink , remaining } ; return Ok (Instruction :: UpdatePriceFeedWithChainlink { accounts , args }) ; } , [243u8 , 6u8 , 8u8 , 23u8 , 126u8 , 181u8 , 251u8 , 158u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UpdateTokenMetadataArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let metadata = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let metadata_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UpdateTokenMetadataAccounts { authority , store , metadata , metadata_program , remaining } ; return Ok (Instruction :: UpdateTokenMetadata { accounts , args }) ; } , [135u8 , 173u8 , 217u8 , 216u8 , 193u8 , 37u8 , 115u8 , 159u8] => { let mut rdr : & [u8] = rest ; let (args , _left) = UseClaimableAccountArguments :: read (rdr) ? ; let mut keys = account_keys . iter () ; let authority = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let store = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let mint = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let owner = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let account = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let system_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let token_program = keys . next () . unwrap_or (& "" . to_string ()) . clone () ; let remaining = keys . cloned () . collect () ; let accounts = UseClaimableAccountAccounts { authority , store , mint , owner , account , system_program , token_program , remaining } ; return Ok (Instruction :: UseClaimableAccount { accounts , args }) ; } , _ => anyhow :: bail ! ("Unknown discriminator: {:?}" , disc) } } } pub mod events { use super :: * ; use serde :: Serialize ; pub const EVENT_LOG_DISCRIMINATOR : [u8 ; 8] = [228 , 69 , 165 , 46 , 81 , 203 , 154 , 29] ; # [derive (Debug , Serialize)] pub enum Event { } impl Event { pub fn decode (_data : & [u8]) -> anyhow :: Result < Self > { anyhow :: bail ! ("Event decoding not implemented") } } } pub use accounts_data :: * ; pub use types :: * ; pub use ix_data :: * ; pub use events :: * ;